<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InjectionModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model</a> &gt; <span class="el_source">InjectionModel.java</span></div><h1>InjectionModel.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyhacked (H) 2012-2025.
 * This program and the accompanying materials
 * are made available under no term at all, use it like
 * you want, but share and discuss it
 * every time possible with every body.
 * 
 * Contributors:
 *      ron190 at ymail dot com - initial implementation
 ******************************************************************************/
package com.jsql.model;

import com.jsql.model.accessible.DataAccess;
import com.jsql.model.accessible.ResourceAccess;
import com.jsql.view.subscriber.Seal;
import com.jsql.model.exception.JSqlException;
import com.jsql.model.exception.JSqlRuntimeException;
import com.jsql.model.injection.method.AbstractMethodInjection;
import com.jsql.model.injection.method.MediatorMethod;
import com.jsql.model.injection.strategy.MediatorStrategy;
import com.jsql.model.injection.strategy.blind.callable.AbstractCallableBit;
import com.jsql.model.injection.engine.MediatorEngine;
import com.jsql.model.injection.engine.model.EngineYaml;
import com.jsql.util.*;
import com.jsql.util.GitUtil.ShowOnConsole;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.io.Serializable;
import java.net.*;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpRequest.Builder;
import java.net.http.HttpResponse;
import java.net.http.HttpResponse.BodyHandlers;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.time.Duration;
import java.util.AbstractMap.SimpleEntry;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Model class of MVC pattern for processing SQL injection automatically.&lt;br&gt;
 * Different views can be attached to this observable, like Swing or command line, in order to separate
 * the functional job from the graphical processing.&lt;br&gt;
 * The Model has a specific database engine and strategy which run an automatic injection to get name of
 * databases, tables, columns and values, and it can also retrieve resources like files and shell.&lt;br&gt;
 * Tasks are run in multi-threads in general to speed the process.
 */
public class InjectionModel extends AbstractModelObservable implements Serializable {
    
<span class="fc" id="L59">    private static final Logger LOGGER = LogManager.getRootLogger();</span>
    
<span class="fc" id="L61">    private final transient MediatorEngine mediatorEngine = new MediatorEngine(this);</span>
<span class="fc" id="L62">    private final transient MediatorMethod mediatorMethod = new MediatorMethod(this);</span>
<span class="fc" id="L63">    private final transient DataAccess dataAccess = new DataAccess(this);</span>
<span class="fc" id="L64">    private final transient ResourceAccess resourceAccess = new ResourceAccess(this);</span>
<span class="fc" id="L65">    private final transient PropertiesUtil propertiesUtil = new PropertiesUtil();</span>
    private final transient MediatorUtils mediatorUtils;
    private final transient MediatorStrategy mediatorStrategy;

    public static final String STAR = &quot;*&quot;;
    public static final String BR = &quot;&lt;br&gt;&amp;#10;&quot;;

    /**
     * initialUrl transformed to a correct injection url.
     */
<span class="fc" id="L75">    private String analysisReport = StringUtils.EMPTY;</span>

    /**
     * Allow to directly start an injection after a failed one
     * without asking the user 'Start a new injection?'.
     */
<span class="fc" id="L81">    private boolean shouldErasePreviousInjection = false;</span>
<span class="fc" id="L82">    private boolean isScanning = false;</span>

<span class="fc" id="L84">    public InjectionModel() {</span>
<span class="fc" id="L85">        this.mediatorStrategy = new MediatorStrategy(this);</span>
<span class="fc" id="L86">        this.mediatorUtils = new MediatorUtils(</span>
            this.propertiesUtil,
            new ConnectionUtil(this),
            new AuthenticationUtil(),
            new GitUtil(this),
            new HeaderUtil(this),
            new ParameterUtil(this),
            new ExceptionUtil(this),
            new SoapUtil(this),
            new MultipartUtil(this),
            new CookiesUtil(this),
            new JsonUtil(this),
            new PreferencesUtil(),
            new ProxyUtil(),
            new ThreadUtil(this),
            new TamperingUtil(),
            new UserAgentUtil(),
            new CsrfUtil(this),
            new DigestUtil(this),
            new FormUtil(this),
            new CertificateUtil()
        );
<span class="fc" id="L108">    }</span>

    /**
     * Reset each injection attributes: Database metadata, General Thread status, Strategy.
     */
    public void resetModel() {
<span class="fc" id="L114">        this.mediatorStrategy.getTime().setApplicable(false);</span>
<span class="fc" id="L115">        this.mediatorStrategy.getBlindBin().setApplicable(false);</span>
<span class="fc" id="L116">        this.mediatorStrategy.getBlindBit().setApplicable(false);</span>
<span class="fc" id="L117">        this.mediatorStrategy.getMultibit().setApplicable(false);</span>
<span class="fc" id="L118">        this.mediatorStrategy.getDns().setApplicable(false);</span>
<span class="fc" id="L119">        this.mediatorStrategy.getError().setApplicable(false);</span>
<span class="fc" id="L120">        this.mediatorStrategy.getStack().setApplicable(false);</span>
<span class="fc" id="L121">        this.mediatorStrategy.getUnion().setApplicable(false);</span>
<span class="fc" id="L122">        this.mediatorStrategy.setStrategy(null);</span>

<span class="fc" id="L124">        this.mediatorStrategy.getSpecificUnion().setVisibleIndex(null);</span>
<span class="fc" id="L125">        this.mediatorStrategy.getSpecificUnion().setIndexesInUrl(StringUtils.EMPTY);</span>

<span class="fc" id="L127">        this.analysisReport = StringUtils.EMPTY;</span>
<span class="fc" id="L128">        this.isStoppedByUser = false;</span>
<span class="fc" id="L129">        this.shouldErasePreviousInjection = false;</span>

<span class="fc" id="L131">        this.mediatorUtils.csrfUtil().setTokenCsrf(null);</span>
<span class="fc" id="L132">        this.mediatorUtils.digestUtil().setTokenDigest(null);</span>
<span class="fc" id="L133">        this.mediatorUtils.threadUtil().reset();</span>
<span class="fc" id="L134">    }</span>

    /**
     * Prepare the injection process, can be interrupted by the user (via shouldStopAll).
     * Erase all attributes eventually defined in a previous injection.
     * Run by Scan, Standard and TU.
     */
    public void beginInjection() {
<span class="fc" id="L142">        this.resetModel();</span>
        try {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if (this.mediatorUtils.proxyUtil().isNotLive(ShowOnConsole.YES)) {</span>
<span class="nc" id="L145">                return;</span>
            }
<span class="fc" id="L147">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_INFORM,
                &quot;{}: {}&quot;,
<span class="fc" id="L150">                () -&gt; I18nUtil.valueByKey(&quot;LOG_START_INJECTION&quot;),</span>
<span class="fc" id="L151">                () -&gt; this.mediatorUtils.connectionUtil().getUrlByUser()</span>
            );
            
            // Check general integrity if user's parameters
<span class="fc" id="L155">            this.mediatorUtils.parameterUtil().checkParametersFormat();</span>
<span class="fc" id="L156">            this.mediatorUtils.connectionUtil().testConnection();</span>

            // TODO Check all path params URL segments
<span class="fc" id="L159">            boolean hasFoundInjection = this.mediatorMethod.getQuery().testParameters(false);</span>
<span class="fc" id="L160">            hasFoundInjection = this.mediatorUtils.multipartUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L161">            hasFoundInjection = this.mediatorUtils.soapUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L162">            hasFoundInjection = this.mediatorMethod.getRequest().testParameters(hasFoundInjection);</span>
<span class="fc" id="L163">            hasFoundInjection = this.mediatorMethod.getHeader().testParameters(hasFoundInjection);</span>
<span class="fc" id="L164">            hasFoundInjection = this.mediatorUtils.cookiesUtil().testParameters(hasFoundInjection);</span>

<span class="pc bpc" id="L166" title="1 of 4 branches missed.">            if (hasFoundInjection &amp;&amp; !this.isScanning) {</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (!this.getMediatorUtils().preferencesUtil().isNotShowingVulnReport()) {</span>
<span class="fc" id="L168">                    this.sendToViews(new Seal.CreateAnalysisReport(this.analysisReport));</span>
                }
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (this.getMediatorUtils().preferencesUtil().isZipStrategy()) {</span>
<span class="fc" id="L171">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Zip mode for reduced query size&quot;);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">                } else if (this.getMediatorUtils().preferencesUtil().isDiosStrategy()) {</span>
<span class="fc" id="L173">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Dump In One Shot strategy for single query dump&quot;);</span>
                }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                if (!this.mediatorUtils.preferencesUtil().isNotInjectingMetadata()) {</span>
<span class="fc" id="L176">                    this.dataAccess.getDatabaseInfos();</span>
                }
<span class="fc" id="L178">                this.dataAccess.listDatabases();</span>
            }
            
<span class="fc" id="L181">            LOGGER.log(LogLevelUtil.CONSOLE_DEFAULT, () -&gt; I18nUtil.valueByKey(&quot;LOG_DONE&quot;));</span>
<span class="fc" id="L182">            this.shouldErasePreviousInjection = true;</span>
<span class="nc" id="L183">        } catch (InterruptedException e) {</span>
<span class="nc" id="L184">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="nc" id="L185">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L186">        } catch (JSqlRuntimeException | JSqlException | IOException e) {  // Catch expected exceptions only</span>
<span class="nc" id="L187">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
                &quot;Interruption: {}&quot;,
<span class="nc bnc" id="L190" title="All 2 branches missed.">                e.getMessage() == null ? InjectionModel.getImplicitReason(e) : e.getMessage()</span>
            );
        } finally {
<span class="fc" id="L193">            this.sendToViews(new Seal.EndPreparation());</span>
        }
<span class="fc" id="L195">    }</span>
    
    public static String getImplicitReason(Throwable e) {
<span class="nc" id="L198">        String message = e.getClass().getSimpleName();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (e.getMessage() != null) {</span>
<span class="nc" id="L200">            message += &quot;: &quot;+ e.getMessage();</span>
        }
<span class="nc bnc" id="L202" title="All 4 branches missed.">        if (e.getCause() != null &amp;&amp; !e.equals(e.getCause())) {</span>
<span class="nc" id="L203">            message += &quot; &gt; &quot;+ InjectionModel.getImplicitReason(e.getCause());</span>
        }
<span class="nc" id="L205">        return message;</span>
    }
    
    /**
     * Run an HTTP connection to the web server.
     * @param dataInjection SQL query
     * @return source code of current page
     */
    @Override
    public String inject(
        String dataInjection,
        boolean isUsingIndex,
        String metadataInjectionProcess,
        AbstractCallableBit&lt;?&gt; callableBoolean,
        boolean isReport
    ) {
        // Temporary url, we go from &quot;select 1,2,3,4...&quot; to &quot;select 1,([complex query]),2...&quot;, but keep initial url
<span class="fc" id="L222">        String urlInjection = this.mediatorUtils.connectionUtil().getUrlBase();</span>
<span class="fc" id="L223">        urlInjection = this.mediatorStrategy.buildPath(urlInjection, isUsingIndex, dataInjection);</span>
<span class="fc" id="L224">        urlInjection = StringUtil.cleanSql(urlInjection.trim());</span>

        URL urlObject;
        String urlInjectionFixed;
        try {
<span class="fc" id="L229">            urlInjectionFixed = this.initQueryString(</span>
                isUsingIndex,
                urlInjection,
                dataInjection
            );
<span class="fc" id="L234">            urlObject = new URI(urlInjectionFixed).toURL();</span>
<span class="nc" id="L235">        } catch (MalformedURLException | URISyntaxException e) {</span>
<span class="nc" id="L236">            LOGGER.log(LogLevelUtil.CONSOLE_ERROR, String.format(&quot;Incorrect Query Url: %s&quot;, e.getMessage()));</span>
<span class="nc" id="L237">            return StringUtils.EMPTY;</span>
<span class="fc" id="L238">        }</span>

<span class="fc" id="L240">        String pageSource = StringUtils.EMPTY;</span>
        
        // Define the connection
        try {
<span class="fc" id="L244">            var httpRequestBuilder = HttpRequest.newBuilder()</span>
<span class="fc" id="L245">                .uri(URI.create(urlObject.toString()))</span>
<span class="fc" id="L246">                .setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/plain&quot;)</span>
<span class="fc" id="L247">                .timeout(Duration.ofSeconds(15));</span>
            
<span class="fc" id="L249">            this.mediatorUtils.csrfUtil().addHeaderToken(httpRequestBuilder);</span>
<span class="fc" id="L250">            this.mediatorUtils.digestUtil().addHeaderToken(httpRequestBuilder);</span>
<span class="fc" id="L251">            this.mediatorUtils.connectionUtil().setCustomUserAgent(httpRequestBuilder);</span>

<span class="fc" id="L253">            String body = this.initRequest(isUsingIndex, dataInjection, httpRequestBuilder);</span>
<span class="fc" id="L254">            this.initHeader(isUsingIndex, dataInjection, httpRequestBuilder);</span>
            
<span class="fc" id="L256">            var httpRequest = httpRequestBuilder.build();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (isReport) {</span>
<span class="fc" id="L258">                Color colorReport = UIManager.getColor(&quot;TextArea.inactiveForeground&quot;);</span>
<span class="fc" id="L259">                String report = InjectionModel.BR + StringUtil.formatReport(colorReport, &quot;Method: &quot;) + httpRequest.method();</span>
<span class="fc" id="L260">                report += InjectionModel.BR + StringUtil.formatReport(colorReport, &quot;Path: &quot;) + httpRequest.uri().getPath();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (httpRequest.uri().getQuery() != null) {</span>
<span class="fc" id="L262">                    report += InjectionModel.BR + StringUtil.formatReport(colorReport, &quot;Query: &quot;) + httpRequest.uri().getQuery();</span>
                }
<span class="fc" id="L264">                if (</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                    !(this.mediatorUtils.parameterUtil().getListRequest().isEmpty()</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                    &amp;&amp; this.mediatorUtils.csrfUtil().getTokenCsrf() == null)</span>
                ) {
<span class="fc" id="L268">                    report += InjectionModel.BR + StringUtil.formatReport(colorReport, &quot;Body: &quot;) + body;</span>
                }
<span class="fc" id="L270">                report += InjectionModel.BR </span>
<span class="fc" id="L271">                    + StringUtil.formatReport(colorReport, &quot;Header: &quot;) </span>
<span class="fc" id="L272">                    + httpRequest.headers().map().entrySet().stream()</span>
<span class="fc" id="L273">                    .map(entry -&gt; </span>
<span class="fc" id="L274">                        String.format(&quot;%s: %s&quot;, entry.getKey(), </span>
<span class="fc" id="L275">                        String.join(StringUtils.EMPTY, entry.getValue()))</span>
                    )
<span class="fc" id="L277">                    .collect(Collectors.joining(InjectionModel.BR));</span>
<span class="fc" id="L278">                return report;</span>
            }
            
<span class="fc" id="L281">            HttpResponse&lt;String&gt; response = this.getMediatorUtils().connectionUtil().getHttpClient().build().send(</span>
<span class="fc" id="L282">                httpRequestBuilder.build(),</span>
<span class="fc" id="L283">                BodyHandlers.ofString()</span>
            );
<span class="fc bfc" id="L285" title="All 2 branches covered.">            if (this.mediatorUtils.parameterUtil().isRequestSoap()) {</span>
                // Invalid XML control chars like \x04 requires urlencoding from server
<span class="fc" id="L287">                pageSource = URLDecoder.decode(response.body(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L288">                pageSource = StringUtil.fromHtml(pageSource);</span>
            } else {
<span class="fc" id="L290">                pageSource = response.body();</span>
            }

<span class="fc" id="L293">            Map&lt;String, String&gt; headersResponse = ConnectionUtil.getHeadersMap(response);</span>
<span class="fc" id="L294">            int sizeHeaders = headersResponse.keySet()</span>
<span class="fc" id="L295">                .stream()</span>
<span class="fc" id="L296">                .map(key -&gt; headersResponse.get(key).length() + key.length())</span>
<span class="fc" id="L297">                .mapToInt(Integer::intValue)</span>
<span class="fc" id="L298">                .sum();</span>
<span class="fc" id="L299">            float size = (float) (pageSource.length() + sizeHeaders) / 1024;</span>
<span class="fc" id="L300">            var decimalFormat = new DecimalFormat(&quot;0.000&quot;);</span>

<span class="fc" id="L302">            String pageSourceFixed = pageSource</span>
<span class="fc" id="L303">                .replaceAll(&quot;(&quot;+ EngineYaml.CALIBRATOR_SQL +&quot;){60,}&quot;, &quot;$1...&quot;)  // Remove ranges of # created by calibration</span>
<span class="fc" id="L304">                .replaceAll(&quot;(jIyM){60,}&quot;, &quot;$1...&quot;);  // Remove batch of chars created by Dios</span>

            // Send data to Views
<span class="fc" id="L307">            this.sendToViews(new Seal.MessageHeader(</span>
                urlInjectionFixed,
                body,
<span class="fc" id="L310">                ConnectionUtil.getHeadersMap(httpRequest.headers()),</span>
                headersResponse,
                pageSourceFixed,
<span class="fc" id="L313">                decimalFormat.format(size),</span>
<span class="fc" id="L314">                this.mediatorStrategy.getMeta(),</span>
                metadataInjectionProcess,
                callableBoolean
            ));
<span class="nc" id="L318">        } catch (IOException e) {</span>
<span class="nc" id="L319">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L321">                String.format(&quot;Error during connection: %s&quot;, e.getMessage())</span>
            );
<span class="nc" id="L323">        } catch (InterruptedException e) {</span>
<span class="nc" id="L324">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="nc" id="L325">            Thread.currentThread().interrupt();</span>
<span class="pc" id="L326">        }</span>

<span class="fc" id="L328">        return pageSource;</span>
    }

    private String initQueryString(
        boolean isUsingIndex,
        String urlInjection,
        String dataInjection
    ) throws URISyntaxException, MalformedURLException {
<span class="fc" id="L336">        String urlInjectionFixed = urlInjection;</span>
<span class="fc" id="L337">        if (</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            this.mediatorUtils.parameterUtil().getListQueryString().isEmpty()</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            &amp;&amp; !this.mediatorUtils.preferencesUtil().isProcessingCsrf()</span>
        ) {
<span class="fc" id="L341">            return urlInjectionFixed;</span>
        }
            
        // URL without query string like Request and Header can receive
        // new params from &lt;form&gt; parsing, in that case add the '?' to URL
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (!urlInjectionFixed.contains(&quot;?&quot;)) {</span>
<span class="nc" id="L347">            urlInjectionFixed += &quot;?&quot;;</span>
        }
<span class="fc" id="L349">        urlInjectionFixed += this.buildQuery(</span>
<span class="fc" id="L350">            this.mediatorMethod.getQuery(),</span>
<span class="fc" id="L351">            this.mediatorUtils.parameterUtil().getQueryStringFromEntries(),</span>
            isUsingIndex,
            dataInjection
        );
<span class="fc" id="L355">        return this.mediatorUtils.csrfUtil().addQueryStringToken(urlInjectionFixed);</span>
    }

    private void initHeader(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest
    ) {
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (!this.mediatorUtils.parameterUtil().getListHeader().isEmpty()) {</span>
<span class="fc" id="L364">            Stream.of(</span>
<span class="fc" id="L365">                this.buildQuery(</span>
<span class="fc" id="L366">                    this.mediatorMethod.getHeader(),</span>
<span class="fc" id="L367">                    this.mediatorUtils.parameterUtil().getHeaderFromEntries(),</span>
                    isUsingIndex,
                    dataInjection
                )
<span class="fc" id="L371">                .split(&quot;\\\\r\\\\n&quot;)</span>
            )
<span class="fc" id="L373">            .forEach(header -&gt; {</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (header.split(&quot;:&quot;).length == 2) {</span>
                    try {  // TODO Should not catch, rethrow or use runtime exception
<span class="fc" id="L376">                        HeaderUtil.sanitizeHeaders(</span>
                            httpRequest,
                            new SimpleEntry&lt;&gt;(
<span class="fc" id="L379">                                header.split(&quot;:&quot;)[0],</span>
<span class="fc" id="L380">                                header.split(&quot;:&quot;)[1]</span>
                            )
                        );
<span class="nc" id="L383">                    } catch (JSqlException e) {</span>
<span class="nc" id="L384">                        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Headers sanitizing issue caught already during connection, ignoring&quot;, e);</span>
<span class="fc" id="L385">                    }</span>
                }
<span class="fc" id="L387">            });</span>
        }
<span class="fc" id="L389">    }</span>

    private String initRequest(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest
    ) {
<span class="fc" id="L396">        if (</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            this.mediatorUtils.parameterUtil().getListRequest().isEmpty()</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            &amp;&amp; this.mediatorUtils.csrfUtil().getTokenCsrf() == null</span>
        ) {
<span class="fc" id="L400">            return dataInjection;</span>
        }
            
        // Set connection method
        // Active for query string injection too, in that case inject query string still with altered method
        
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (this.mediatorUtils.parameterUtil().isRequestSoap()) {</span>
<span class="fc" id="L407">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/xml&quot;);</span>
        } else {
<span class="fc" id="L409">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;application/x-www-form-urlencoded&quot;);</span>
        }

<span class="fc" id="L412">        var body = new StringBuilder();</span>
<span class="fc" id="L413">        this.mediatorUtils.csrfUtil().addRequestToken(body);</span>
            
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (this.mediatorUtils.connectionUtil().getTypeRequest().matches(&quot;PUT|POST&quot;)) {</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (this.mediatorUtils.parameterUtil().isRequestSoap()) {</span>
<span class="fc" id="L417">                body.append(</span>
<span class="fc" id="L418">                    this.buildQuery(</span>
<span class="fc" id="L419">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L420">                        this.mediatorUtils.parameterUtil().getRawRequest(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                    // Invalid XML characters in recent Spring version
                    // Server needs to urldecode, or stop using out of range chars
<span class="fc" id="L426">                    .replace(&quot;\u0001&quot;, &quot;&amp;#01;&quot;)</span>
<span class="fc" id="L427">                    .replace(&quot;\u0003&quot;, &quot;&amp;#03;&quot;)</span>
<span class="fc" id="L428">                    .replace(&quot;\u0004&quot;, &quot;&amp;#04;&quot;)</span>
<span class="fc" id="L429">                    .replace(&quot;\u0005&quot;, &quot;&amp;#05;&quot;)</span>
<span class="fc" id="L430">                    .replace(&quot;\u0006&quot;, &quot;&amp;#06;&quot;)</span>
<span class="fc" id="L431">                    .replace(&quot;\u0007&quot;, &quot;&amp;#07;&quot;)</span>
<span class="fc" id="L432">                    .replace(&quot;+&quot;, &quot;%2B&quot;)  // Prevent replace '+' into 'space' on server side urldecode</span>
                );
            } else {
<span class="fc" id="L435">                body.append(</span>
<span class="fc" id="L436">                    this.buildQuery(</span>
<span class="fc" id="L437">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L438">                        this.mediatorUtils.parameterUtil().getRequestFromEntries(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                );
            }
        }
        
<span class="fc" id="L446">        var bodyPublisher = BodyPublishers.ofString(body.toString());</span>
<span class="fc" id="L447">        httpRequest.method(</span>
<span class="fc" id="L448">            this.mediatorUtils.connectionUtil().getTypeRequest(),</span>
            bodyPublisher
        );
<span class="fc" id="L451">        return body.toString();</span>
    }
    
    private String buildQuery(AbstractMethodInjection methodInjection, String paramLead, boolean isUsingIndex, String sqlTrail) {
        String query;
<span class="fc" id="L456">        String paramLeadFixed = paramLead.replace(</span>
            InjectionModel.STAR,
            TamperingUtil.TAG_OPENED + InjectionModel.STAR + TamperingUtil.TAG_CLOSED
        );
<span class="fc" id="L460">        if (</span>
            // No parameter transformation if method is not selected by user
<span class="fc bfc" id="L462" title="All 2 branches covered.">            this.mediatorUtils.connectionUtil().getMethodInjection() != methodInjection</span>
            // No parameter transformation if injection point in URL
<span class="fc bfc" id="L464" title="All 2 branches covered.">            || this.mediatorUtils.connectionUtil().getUrlBase().contains(InjectionModel.STAR)</span>
        ) {
<span class="fc" id="L466">            query = paramLeadFixed;  // Just pass parameters without any transformation</span>
<span class="fc" id="L467">        } else if (</span>
            // If method is selected by user and URL does not contain injection point
            // but parameters contain an injection point
            // then replace injection point by SQL expression in this parameter
<span class="fc bfc" id="L471" title="All 2 branches covered.">            paramLeadFixed.contains(InjectionModel.STAR)</span>
        ) {
<span class="fc" id="L473">            query = this.initStarInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
        } else {
<span class="fc" id="L475">            query = this.initRawInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
        }
<span class="fc" id="L477">        query = this.cleanQuery(methodInjection, query);  // Remove comments except empty /**/</span>
        // Add empty comments with space=&gt;/**/
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (this.mediatorUtils.connectionUtil().getMethodInjection() == methodInjection) {</span>
<span class="fc" id="L480">            query = this.mediatorUtils.tamperingUtil().tamper(query);</span>
        }
<span class="fc" id="L482">        return this.applyEncoding(methodInjection, query);</span>
    }

    private String initRawInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        String query;
        // Method is selected by user and there's no injection point
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (!isUsingIndex) {</span>
            // Several SQL expressions does not use indexes in SELECT,
            // like Boolean, Error, Shell and search for character insertion,
            // in that case concat SQL expression to the end of param.
<span class="fc" id="L492">            query = paramLead + sqlTrail;</span>
        } else {
            // Concat indexes found for Union strategy to params
            // and use visible Index for injection
<span class="nc" id="L496">            query = paramLead + this.getMediatorStrategy().getSpecificUnion().getIndexesInUrl().replaceAll(</span>
<span class="nc" id="L497">                String.format(EngineYaml.FORMAT_INDEX, this.mediatorStrategy.getSpecificUnion().getVisibleIndex()),</span>
                // Oracle column often contains $, which is reserved for regex.
                // =&gt; need to be escape with quoteReplacement()
<span class="nc" id="L500">                Matcher.quoteReplacement(sqlTrail)</span>
            );
        }
        // Add ending line comment by engine
<span class="fc" id="L504">        return query + this.mediatorEngine.getEngine().instance().endingComment();</span>
    }

    private String initStarInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        String query;
        // Several SQL expressions does not use indexes in SELECT,
        // like Boolean, Error, Shell and search for character insertion,
        // in that case replace injection point by SQL expression.
        // Injection point is always at the end?
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (!isUsingIndex) {</span>
<span class="fc" id="L514">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L516">                sqlTrail + this.mediatorEngine.getEngine().instance().endingComment()</span>
            );
        } else {
            // Replace injection point by indexes found for Union strategy
            // and use visible Index for injection
<span class="fc" id="L521">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L523">                this.mediatorStrategy.getSpecificUnion().getIndexesInUrl().replace(</span>
<span class="fc" id="L524">                    String.format(EngineYaml.FORMAT_INDEX, this.mediatorStrategy.getSpecificUnion().getVisibleIndex()),</span>
                    sqlTrail
                )
<span class="fc" id="L527">                + this.mediatorEngine.getEngine().instance().endingComment()</span>
            );
        }
<span class="fc" id="L530">        return query;</span>
    }

    /**
     * Dependency:
     * - Tamper space=&gt;comment
     */
    private String cleanQuery(AbstractMethodInjection methodInjection, String query) {
<span class="fc" id="L538">        String queryFixed = query;</span>
<span class="fc" id="L539">        if (</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            methodInjection == this.mediatorMethod.getRequest()</span>
            &amp;&amp; (
<span class="fc bfc" id="L542" title="All 2 branches covered.">                this.mediatorUtils.parameterUtil().isRequestSoap()</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                || this.mediatorUtils.parameterUtil().isMultipartRequest()</span>
            )
        ) {
<span class="fc" id="L546">            queryFixed = StringUtil.removeSqlComment(queryFixed)</span>
<span class="fc" id="L547">                .replace(&quot;+&quot;, &quot; &quot;)</span>
<span class="fc" id="L548">                .replace(&quot;%2b&quot;, &quot;+&quot;)  // Failsafe</span>
<span class="fc" id="L549">                .replace(&quot;%23&quot;, &quot;#&quot;);  // End comment</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (this.mediatorUtils.parameterUtil().isMultipartRequest()) {</span>
                // restore linefeed from textfield
<span class="fc" id="L552">                queryFixed = queryFixed.replaceAll(&quot;(?s)\\\\n&quot;, &quot;\r\n&quot;);</span>
            }
        } else {
<span class="fc" id="L555">            queryFixed = StringUtil.cleanSql(queryFixed);</span>
        }
<span class="fc" id="L557">        return queryFixed;</span>
    }

    private String applyEncoding(AbstractMethodInjection methodInjection, String query) {
<span class="fc" id="L561">        String queryFixed = query;</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (!this.mediatorUtils.parameterUtil().isRequestSoap()) {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if (methodInjection == this.mediatorMethod.getQuery()) {</span>
                // URL encode each character because no query parameter context
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                if (!this.mediatorUtils.preferencesUtil().isUrlEncodingDisabled()) {</span>
<span class="fc" id="L566">                    queryFixed = queryFixed.replace(&quot;'&quot;, &quot;%27&quot;);</span>
<span class="fc" id="L567">                    queryFixed = queryFixed.replace(&quot;(&quot;, &quot;%28&quot;);</span>
<span class="fc" id="L568">                    queryFixed = queryFixed.replace(&quot;)&quot;, &quot;%29&quot;);</span>
<span class="fc" id="L569">                    queryFixed = queryFixed.replace(&quot;{&quot;, &quot;%7b&quot;);</span>
<span class="fc" id="L570">                    queryFixed = queryFixed.replace(&quot;[&quot;, &quot;%5b&quot;);</span>
<span class="fc" id="L571">                    queryFixed = queryFixed.replace(&quot;]&quot;, &quot;%5d&quot;);</span>
<span class="fc" id="L572">                    queryFixed = queryFixed.replace(&quot;}&quot;, &quot;%7d&quot;);</span>
<span class="fc" id="L573">                    queryFixed = queryFixed.replace(&quot;&gt;&quot;, &quot;%3e&quot;);</span>
<span class="fc" id="L574">                    queryFixed = queryFixed.replace(&quot;&lt;&quot;, &quot;%3c&quot;);</span>
<span class="fc" id="L575">                    queryFixed = queryFixed.replace(&quot;?&quot;, &quot;%3f&quot;);</span>
<span class="fc" id="L576">                    queryFixed = queryFixed.replace(&quot;_&quot;, &quot;%5f&quot;);</span>
<span class="fc" id="L577">                    queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
                }
                // HTTP forbidden characters
<span class="fc" id="L580">                queryFixed = queryFixed.replace(StringUtils.SPACE, &quot;+&quot;);</span>
<span class="fc" id="L581">                queryFixed = queryFixed.replace(&quot;`&quot;, &quot;%60&quot;);  // from `${database}`.`${table}`</span>
<span class="fc" id="L582">                queryFixed = queryFixed.replace(&quot;\&quot;&quot;, &quot;%22&quot;);</span>
<span class="fc" id="L583">                queryFixed = queryFixed.replace(&quot;|&quot;, &quot;%7c&quot;);</span>
<span class="fc" id="L584">                queryFixed = queryFixed.replace(&quot;\\&quot;, &quot;%5c&quot;);</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            } else if (methodInjection != this.mediatorMethod.getRequest()) {</span>
                // For cookies in Spring (confirmed, covered by integration tests)
<span class="fc" id="L587">                queryFixed = queryFixed.replace(&quot;+&quot;, &quot;%20&quot;);</span>
<span class="fc" id="L588">                queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
                try {  // fix #95709: IllegalArgumentException on decode()
<span class="fc" id="L590">                    queryFixed = URLDecoder.decode(queryFixed, StandardCharsets.UTF_8);</span>
<span class="nc" id="L591">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L592">                    LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Incorrect values in [{}], please check the parameters&quot;, methodInjection.name());</span>
<span class="nc" id="L593">                    throw new JSqlRuntimeException(e);</span>
<span class="fc" id="L594">                }</span>
            }
        }
<span class="fc" id="L597">        return queryFixed;</span>
    }
    
    /**
     * Display source code in console.
     * @param message Error message
     * @param source Text to display in console
     */
    public void sendResponseFromSite(String message, String source) {
<span class="nc" id="L606">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;{}, response from site:&quot;, message);</span>
<span class="nc" id="L607">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;&gt;&gt;&gt;{}&quot;, source);</span>
<span class="nc" id="L608">    }</span>
    
    
    // Getters and setters

    public boolean shouldErasePreviousInjection() {
<span class="nc" id="L614">        return this.shouldErasePreviousInjection;</span>
    }

    public void setIsScanning(boolean isScanning) {
<span class="fc" id="L618">        this.isScanning = isScanning;</span>
<span class="fc" id="L619">    }</span>

    public PropertiesUtil getPropertiesUtil() {
<span class="fc" id="L622">        return this.propertiesUtil;</span>
    }

    public MediatorUtils getMediatorUtils() {
<span class="fc" id="L626">        return this.mediatorUtils;</span>
    }

    public MediatorEngine getMediatorEngine() {
<span class="fc" id="L630">        return this.mediatorEngine;</span>
    }

    public MediatorMethod getMediatorMethod() {
<span class="fc" id="L634">        return this.mediatorMethod;</span>
    }

    public DataAccess getDataAccess() {
<span class="fc" id="L638">        return this.dataAccess;</span>
    }

    public ResourceAccess getResourceAccess() {
<span class="fc" id="L642">        return this.resourceAccess;</span>
    }

    public MediatorStrategy getMediatorStrategy() {
<span class="fc" id="L646">        return this.mediatorStrategy;</span>
    }

    public void appendAnalysisReport(String analysisReport) {
<span class="fc" id="L650">        this.appendAnalysisReport(analysisReport, false);</span>
<span class="fc" id="L651">    }</span>

    public void appendAnalysisReport(String analysisReport, boolean isInit) {
<span class="fc bfc" id="L654" title="All 2 branches covered.">        this.analysisReport += (isInit ? StringUtils.EMPTY : &quot;&lt;br&gt;&amp;#10;&lt;br&gt;&amp;#10;&quot;) + analysisReport;</span>
<span class="fc" id="L655">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>