<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DiffMatchPatch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model.injection.strategy.blind.patch</a> &gt; <span class="el_source">DiffMatchPatch.java</span></div><h1>DiffMatchPatch.java</h1><pre class="source lang-java linenums">/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jsql.model.injection.strategy.blind.patch;

import org.apache.commons.lang3.StringUtils;

import java.util.*;
import java.util.regex.Pattern;

/*
 * Functions for diff, match and patch.
 * Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 *
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * Also contains the behaviour settings.
 */
<span class="fc" id="L38">public class DiffMatchPatch {</span>

    // Defaults.
    // Set these on your diff_match_patch instance to override the defaults.

    /**
     * Number of seconds to map a diff before giving up (0 for infinity).
     */
    public static final float DIFF_TIMEOUT = 1.0f;

    /**
     * Cost of an empty edit operation in terms of edit characters.
     */
    public static final short DIFF_EDIT_COST = 4;

    // Define some regex patterns for matching boundaries.
<span class="fc" id="L54">    private static final Pattern BLANK_LINE_END = Pattern.compile(&quot;\\n\\r?\\n\\Z&quot;, Pattern.DOTALL);</span>
<span class="fc" id="L55">    private static final Pattern BLANK_LINE_START = Pattern.compile(&quot;\\A\\r?\\n\\r?\\n&quot;, Pattern.DOTALL);</span>

    /**
     * Internal class for returning results from diff_linesToChars().
     * Other less paranoid languages just use a three-element array.
     */
<span class="fc" id="L61">    protected record LinesToCharsResult(String chars1, String chars2, List&lt;String&gt; lineArray) {}</span>

    //  DIFF FUNCTIONS

    /**
     * The data structure representing a diff is a Linked list of Diff objects:
     * {Diff(Operation.DELETE, &quot;Hello&quot;), Diff(Operation.INSERT, &quot;Goodbye&quot;),
     *  Diff(Operation.EQUAL, &quot; world.&quot;)}
     * which means: delete &quot;Hello&quot;, add &quot;Goodbye&quot; and keep &quot; world.&quot;
     */
<span class="fc" id="L71">    public enum Operation {</span>
<span class="fc" id="L72">        DELETE, INSERT, EQUAL</span>
    }

    /**
     * Find the differences between two texts.
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag.  If false, then don't run a
     *     line-level diff first to identify the changed areas.
     *     If true, then run a faster slightly less optimal diff.
     * @return Linked List of Diff objects.
     */
    public LinkedList&lt;Diff&gt; diffMain(String text1, String text2, boolean checklines) {
        // Set a deadline by which time the diff must be complete.
<span class="fc" id="L86">        long deadline = System.currentTimeMillis() + (long) (DiffMatchPatch.DIFF_TIMEOUT * 1000);</span>
<span class="fc" id="L87">        return this.diffMain(text1, text2, checklines, deadline);</span>
    }

    /**
     * Find the differences between two texts.  Simplifies the problem by
     * stripping any common prefix or suffix off the texts before diffing.
     * @param valueText1 Old string to be diffed.
     * @param valueText2 New string to be diffed.
     * @param checklines Speedup flag.  If false, then don't run a
     *     line-level diff first to identify the changed areas.
     *     If true, then run a faster slightly less optimal diff.
     * @param deadline Time when the diff should be complete by.  Used
     *     internally for recursive calls.  Users should set DiffTimeout instead.
     * @return Linked List of Diff objects.
     */
    private LinkedList&lt;Diff&gt; diffMain(String valueText1, String valueText2, boolean checklines, long deadline) {
<span class="fc" id="L103">        String text1 = valueText1;</span>
<span class="fc" id="L104">        String text2 = valueText2;</span>

        // Check for null inputs.
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">        if (text1 == null || text2 == null) {</span>
<span class="nc" id="L108">            throw new IllegalArgumentException(&quot;Null inputs. (diff_main)&quot;);</span>
        }

        // Check for equality (speedup).
        LinkedList&lt;Diff&gt; diffs;
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (text1.equals(text2)) {</span>
<span class="fc" id="L114">            diffs = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (!text1.isEmpty()) {</span>
<span class="fc" id="L116">                diffs.add(new Diff(Operation.EQUAL, text1));</span>
            }
<span class="fc" id="L118">            return diffs;</span>
        }

        // Trim off common prefix (speedup).
<span class="fc" id="L122">        int commonlength = this.diffCommonPrefix(text1, text2);</span>
<span class="fc" id="L123">        String commonprefix = text1.substring(0, commonlength);</span>
<span class="fc" id="L124">        text1 = text1.substring(commonlength);</span>
<span class="fc" id="L125">        text2 = text2.substring(commonlength);</span>

        // Trim off common suffix (speedup).
<span class="fc" id="L128">        commonlength = this.diffCommonSuffix(text1, text2);</span>
<span class="fc" id="L129">        String commonsuffix = text1.substring(text1.length() - commonlength);</span>
<span class="fc" id="L130">        text1 = text1.substring(0, text1.length() - commonlength);</span>
<span class="fc" id="L131">        text2 = text2.substring(0, text2.length() - commonlength);</span>

        // Compute the diff on the middle block.
<span class="fc" id="L134">        diffs = this.diffCompute(text1, text2, checklines, deadline);</span>

        // Restore the prefix and suffix.
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (!commonprefix.isEmpty()) {</span>
<span class="fc" id="L138">            diffs.addFirst(new Diff(Operation.EQUAL, commonprefix));</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (!commonsuffix.isEmpty()) {</span>
<span class="fc" id="L141">            diffs.addLast(new Diff(Operation.EQUAL, commonsuffix));</span>
        }

<span class="fc" id="L144">        this.diffCleanupMerge(diffs);</span>
<span class="fc" id="L145">        return diffs;</span>
    }

    /**
     * Find the differences between two texts.  Assumes that the texts do not
     * have any common prefix or suffix.
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag.  If false, then don't run a
     *     line-level diff first to identify the changed areas.
     *     If true, then run a faster slightly less optimal diff.
     * @param deadline Time when the diff should be complete by.
     * @return Linked List of Diff objects.
     */
    private LinkedList&lt;Diff&gt; diffCompute(String text1, String text2, boolean checklines, long deadline) {
<span class="fc" id="L160">        LinkedList&lt;Diff&gt; diffs = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (text1.isEmpty()) {</span>
            // Just add some text (speedup).
<span class="fc" id="L164">            diffs.add(new Diff(Operation.INSERT, text2));</span>
<span class="fc" id="L165">            return diffs;</span>
        }

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (text2.isEmpty()) {</span>
            // Just delete some text (speedup).
<span class="fc" id="L170">            diffs.add(new Diff(Operation.DELETE, text1));</span>
<span class="fc" id="L171">            return diffs;</span>
        }

        {
            // New scope to garbage collect longtext and shorttext.
<span class="fc bfc" id="L176" title="All 2 branches covered.">            String longtext = text1.length() &gt; text2.length() ? text1 : text2;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            String shorttext = text1.length() &gt; text2.length() ? text2 : text1;</span>
<span class="fc" id="L178">            int i = longtext.indexOf(shorttext);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (i != -1) {</span>
                // Shorter text is inside the longer text (speedup).
<span class="fc bfc" id="L181" title="All 2 branches covered.">                Operation op = (text1.length() &gt; text2.length()) ?</span>
<span class="fc" id="L182">                        Operation.DELETE : Operation.INSERT;</span>
<span class="fc" id="L183">                diffs.add(new Diff(op, longtext.substring(0, i)));</span>
<span class="fc" id="L184">                diffs.add(new Diff(Operation.EQUAL, shorttext));</span>
<span class="fc" id="L185">                diffs.add(new Diff(op, longtext.substring(i + shorttext.length())));</span>
<span class="fc" id="L186">                return diffs;</span>
            }

<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (shorttext.length() == 1) {</span>
                // Single character string.
                // After the previous speedup, the character can't be an equality.
<span class="fc" id="L192">                diffs.add(new Diff(Operation.DELETE, text1));</span>
<span class="fc" id="L193">                diffs.add(new Diff(Operation.INSERT, text2));</span>
<span class="fc" id="L194">                return diffs;</span>
            }
        }

        // Check to see if the problem can be split in two.
<span class="fc" id="L199">        String[] hm = this.diffHalfMatch(text1, text2);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (hm != null) {</span>
            // A half-match was found, sort out the return data.
<span class="fc" id="L202">            String text1A = hm[0];</span>
<span class="fc" id="L203">            String text1B = hm[1];</span>
<span class="fc" id="L204">            String text2A = hm[2];</span>
<span class="fc" id="L205">            String text2B = hm[3];</span>
<span class="fc" id="L206">            String midCommon = hm[4];</span>
            // Send both pairs off for separate processing.
<span class="fc" id="L208">            LinkedList&lt;Diff&gt; diffsA = this.diffMain(text1A, text2A, checklines, deadline);</span>
<span class="fc" id="L209">            List&lt;Diff&gt; diffsB = this.diffMain(text1B, text2B, checklines, deadline);</span>
            // Merge the results.
<span class="fc" id="L211">            diffs = diffsA;</span>
<span class="fc" id="L212">            diffs.add(new Diff(Operation.EQUAL, midCommon));</span>
<span class="fc" id="L213">            diffs.addAll(diffsB);</span>
<span class="fc" id="L214">            return diffs;</span>
        }

<span class="fc bfc" id="L217" title="All 6 branches covered.">        if (checklines &amp;&amp; text1.length() &gt; 100 &amp;&amp; text2.length() &gt; 100) {</span>
<span class="fc" id="L218">            return this.diffLineMode(text1, text2, deadline);</span>
        }

<span class="fc" id="L221">        return this.diffBisect(text1, text2, deadline);</span>
    }

    /**
     * Do a quick line-level diff on both strings, then rediff the parts for
     * greater accuracy.
     * This speedup can produce non-minimal diffs.
     * @param valueText1 Old string to be diffed.
     * @param valueText2 New string to be diffed.
     * @param deadline Time when the diff should be complete by.
     * @return Linked List of Diff objects.
     */
    private LinkedList&lt;Diff&gt; diffLineMode(String valueText1, String valueText2, long deadline) {
        // Scan the text on a line-by-line basis first.
<span class="fc" id="L235">        LinesToCharsResult b = this.diffLinesToChars(valueText1, valueText2);</span>
<span class="fc" id="L236">        String text1 = b.chars1;</span>
<span class="fc" id="L237">        String text2 = b.chars2;</span>
<span class="fc" id="L238">        List&lt;String&gt; linearray = b.lineArray;</span>

<span class="fc" id="L240">        LinkedList&lt;Diff&gt; diffs = this.diffMain(text1, text2, false, deadline);</span>

        // Convert the diff back to original text.
<span class="fc" id="L243">        this.diffCharsToLines(diffs, linearray);</span>
        // Eliminate freak matches (e.g. blank lines)
<span class="fc" id="L245">        this.diffCleanupSemantic(diffs);</span>

        // Rediff any replacement blocks, this time character-by-character.
        // Add a dummy entry at the end.
<span class="fc" id="L249">        diffs.add(new Diff(Operation.EQUAL, StringUtils.EMPTY));</span>
<span class="fc" id="L250">        int countDelete = 0;</span>
<span class="fc" id="L251">        int countInsert = 0;</span>
<span class="fc" id="L252">        StringBuilder textDelete = new StringBuilder();</span>
<span class="fc" id="L253">        StringBuilder textInsert = new StringBuilder();</span>
<span class="fc" id="L254">        ListIterator&lt;Diff&gt; pointer = diffs.listIterator();</span>
<span class="fc" id="L255">        Diff thisDiff = pointer.next();</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        while (thisDiff != null) {</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">            switch (thisDiff.getOperation()) {</span>
                case INSERT:
<span class="fc" id="L260">                    countInsert++;</span>
<span class="fc" id="L261">                    textInsert.append(thisDiff.getText());</span>
<span class="fc" id="L262">                    break;</span>
                case DELETE:
<span class="fc" id="L264">                    countDelete++;</span>
<span class="fc" id="L265">                    textDelete.append(thisDiff.getText());</span>
<span class="fc" id="L266">                    break;</span>
                case EQUAL:
                    // Upon reaching an equality, check for prior redundancies.
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">                    if (countDelete &gt;= 1 &amp;&amp; countInsert &gt;= 1) {</span>
                        // Delete the offending records and add the merged ones.
<span class="fc" id="L271">                        pointer.previous();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                        for (int j = 0; j &lt; countDelete + countInsert; j++) {</span>
<span class="fc" id="L273">                            pointer.previous();</span>
<span class="fc" id="L274">                            pointer.remove();</span>
                        }
<span class="fc bfc" id="L276" title="All 2 branches covered.">                        for (Diff newDiff : this.diffMain(textDelete.toString(), textInsert.toString(), false, deadline)) {</span>
<span class="fc" id="L277">                            pointer.add(newDiff);</span>
<span class="fc" id="L278">                        }</span>
                    }
<span class="fc" id="L280">                    countInsert = 0;</span>
<span class="fc" id="L281">                    countDelete = 0;</span>
<span class="fc" id="L282">                    textDelete.setLength(0);</span>
<span class="fc" id="L283">                    textInsert.setLength(0);</span>
                    break;
            }
<span class="fc bfc" id="L286" title="All 2 branches covered.">            thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }
<span class="fc" id="L288">        diffs.removeLast();  // Remove the dummy entry at the end.</span>

<span class="fc" id="L290">        return diffs;</span>
    }

    /**
     * Find the 'middle snake' of a diff, split the problem in two
     * and return the recursively constructed diff.
     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param deadline Time at which to bail if not yet complete.
     * @return LinkedList of Diff objects.
     */
    protected LinkedList&lt;Diff&gt; diffBisect(String text1, String text2, long deadline) {
        // Cache the text lengths to prevent multiple calls.
<span class="fc" id="L304">        int text1Length = text1.length();</span>
<span class="fc" id="L305">        int text2Length = text2.length();</span>
<span class="fc" id="L306">        int maxD = (text1Length + text2Length + 1) / 2;</span>
<span class="fc" id="L307">        int vLength = 2 * maxD;</span>
<span class="fc" id="L308">        int[] v1 = new int[vLength];</span>
<span class="fc" id="L309">        int[] v2 = new int[vLength];</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        for (int x = 0; x &lt; vLength; x++) {</span>
<span class="fc" id="L311">            v1[x] = -1;</span>
<span class="fc" id="L312">            v2[x] = -1;</span>
        }
<span class="fc" id="L314">        v1[maxD + 1] = 0;</span>
<span class="fc" id="L315">        v2[maxD + 1] = 0;</span>
<span class="fc" id="L316">        int delta = text1Length - text2Length;</span>
        // If the total number of characters is odd, then the front path will
        // collide with the reverse path.
<span class="fc bfc" id="L319" title="All 2 branches covered.">        boolean front = delta % 2 != 0;</span>
        // Offsets for start and end of k loop.
        // Prevents mapping of space beyond the grid.
<span class="fc" id="L322">        int k1start = 0;</span>
<span class="fc" id="L323">        int k1end = 0;</span>
<span class="fc" id="L324">        int k2start = 0;</span>
<span class="fc" id="L325">        int k2end = 0;</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int d = 0; d &lt; maxD; d++) {</span>
            // Bail out if deadline is reached.
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (System.currentTimeMillis() &gt; deadline) {</span>
<span class="nc" id="L330">                break;</span>
            }

            // Walk the front path one step.
<span class="fc bfc" id="L334" title="All 2 branches covered.">            for (int k1 = -d + k1start; k1 &lt;= d - k1end; k1 += 2) {</span>
<span class="fc" id="L335">                int k1Offset = maxD + k1;</span>
                int x1;
<span class="fc bfc" id="L337" title="All 6 branches covered.">                if (k1 == -d || (k1 != d &amp;&amp; v1[k1Offset - 1] &lt; v1[k1Offset + 1])) {</span>
<span class="fc" id="L338">                    x1 = v1[k1Offset + 1];</span>
                } else {
<span class="fc" id="L340">                    x1 = v1[k1Offset - 1] + 1;</span>
                }
<span class="fc" id="L342">                int y1 = x1 - k1;</span>
<span class="fc bfc" id="L343" title="All 4 branches covered.">                while (x1 &lt; text1Length &amp;&amp; y1 &lt; text2Length</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                        &amp;&amp; text1.charAt(x1) == text2.charAt(y1)) {</span>
<span class="fc" id="L345">                    x1++;</span>
<span class="fc" id="L346">                    y1++;</span>
                }
<span class="fc" id="L348">                v1[k1Offset] = x1;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">                if (x1 &gt; text1Length) {</span>
                    // Ran off the right of the graph.
<span class="fc" id="L351">                    k1end += 2;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                } else if (y1 &gt; text2Length) {</span>
                    // Ran off the bottom of the graph.
<span class="fc" id="L354">                    k1start += 2;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                } else if (front) {</span>
<span class="fc" id="L356">                    int k2Offset = maxD + delta - k1;</span>
<span class="fc bfc" id="L357" title="All 6 branches covered.">                    if (k2Offset &gt;= 0 &amp;&amp; k2Offset &lt; vLength &amp;&amp; v2[k2Offset] != -1) {</span>
                        // Mirror x2 onto top-left coordinate system.
<span class="fc" id="L359">                        int x2 = text1Length - v2[k2Offset];</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                        if (x1 &gt;= x2) {</span>
                            // Overlap detected.
<span class="fc" id="L362">                            return this.diffBisectSplit(text1, text2, x1, y1, deadline);</span>
                        }
                    }
                }
            }

            // Walk the reverse path one step.
<span class="fc bfc" id="L369" title="All 2 branches covered.">            for (int k2 = -d + k2start; k2 &lt;= d - k2end; k2 += 2) {</span>
<span class="fc" id="L370">                int k2Offset = maxD + k2;</span>
                int x2;
<span class="fc bfc" id="L372" title="All 6 branches covered.">                if (k2 == -d || (k2 != d &amp;&amp; v2[k2Offset - 1] &lt; v2[k2Offset + 1])) {</span>
<span class="fc" id="L373">                    x2 = v2[k2Offset + 1];</span>
                } else {
<span class="fc" id="L375">                    x2 = v2[k2Offset - 1] + 1;</span>
                }
<span class="fc" id="L377">                int y2 = x2 - k2;</span>
<span class="fc bfc" id="L378" title="All 4 branches covered.">                while (x2 &lt; text1Length &amp;&amp; y2 &lt; text2Length</span>
<span class="fc" id="L379">                        &amp;&amp; text1.charAt(text1Length - x2 - 1)</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                        == text2.charAt(text2Length - y2 - 1)) {</span>
<span class="fc" id="L381">                    x2++;</span>
<span class="fc" id="L382">                    y2++;</span>
                }
<span class="fc" id="L384">                v2[k2Offset] = x2;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                if (x2 &gt; text1Length) {</span>
                    // Ran off the left of the graph.
<span class="fc" id="L387">                    k2end += 2;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                } else if (y2 &gt; text2Length) {</span>
                    // Ran off the top of the graph.
<span class="fc" id="L390">                    k2start += 2;</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                } else if (!front) {</span>
<span class="fc" id="L392">                    int k1Offset = maxD + delta - k2;</span>
<span class="fc bfc" id="L393" title="All 6 branches covered.">                    if (k1Offset &gt;= 0 &amp;&amp; k1Offset &lt; vLength &amp;&amp; v1[k1Offset] != -1) {</span>
<span class="fc" id="L394">                        int x1 = v1[k1Offset];</span>
<span class="fc" id="L395">                        int y1 = maxD + x1 - k1Offset;</span>
                        // Mirror x2 onto top-left coordinate system.
<span class="fc" id="L397">                        x2 = text1Length - x2;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                        if (x1 &gt;= x2) {</span>
                            // Overlap detected.
<span class="fc" id="L400">                            return this.diffBisectSplit(text1, text2, x1, y1, deadline);</span>
                        }
                    }
                }
            }
        }
        // Diff took too long and hit the deadline or
        // number of diffs equals number of characters, no commonality at all.
<span class="fc" id="L408">        LinkedList&lt;Diff&gt; diffs = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L409">        diffs.add(new Diff(Operation.DELETE, text1));</span>
<span class="fc" id="L410">        diffs.add(new Diff(Operation.INSERT, text2));</span>
<span class="fc" id="L411">        return diffs;</span>
    }

    /**
     * Given the location of the 'middle snake', split the diff in two parts
     * and recurse.
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param x Index of split point in text1.
     * @param y Index of split point in text2.
     * @param deadline Time at which to bail if not yet complete.
     * @return LinkedList of Diff objects.
     */
    private LinkedList&lt;Diff&gt; diffBisectSplit(String text1, String text2, int x, int y, long deadline) {
<span class="fc" id="L425">        String text1a = text1.substring(0, x);</span>
<span class="fc" id="L426">        String text2a = text2.substring(0, y);</span>
<span class="fc" id="L427">        String text1b = text1.substring(x);</span>
<span class="fc" id="L428">        String text2b = text2.substring(y);</span>

        // Compute both diffs serially.
<span class="fc" id="L431">        LinkedList&lt;Diff&gt; diffs = this.diffMain(text1a, text2a, false, deadline);</span>
<span class="fc" id="L432">        List&lt;Diff&gt; diffsb = this.diffMain(text1b, text2b, false, deadline);</span>

<span class="fc" id="L434">        diffs.addAll(diffsb);</span>
<span class="fc" id="L435">        return diffs;</span>
    }

    /**
     * Split two texts into a list of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * @param text1 First string.
     * @param text2 Second string.
     * @return An object containing the encoded text1, the encoded text2 and
     *     the List of unique strings.  The zeroth element of the List of
     *     unique strings is intentionally blank.
     */
    protected LinesToCharsResult diffLinesToChars(String text1, String text2) {
<span class="fc" id="L448">        List&lt;String&gt; lineArray = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L449">        Map&lt;String, Integer&gt; lineHash = new HashMap&lt;&gt;();</span>
        // e.g. linearray[4] == &quot;Hello\n&quot;
        // e.g. linehash.get(&quot;Hello\n&quot;) == 4

        // &quot;\x00&quot; is a valid character, but various debuggers don't like it.
        // So we'll insert a junk entry to avoid generating a null character.
<span class="fc" id="L455">        lineArray.add(StringUtils.EMPTY);</span>

<span class="fc" id="L457">        String chars1 = this.diffLinesToCharsMunge(text1, lineArray, lineHash);</span>
<span class="fc" id="L458">        String chars2 = this.diffLinesToCharsMunge(text2, lineArray, lineHash);</span>
<span class="fc" id="L459">        return new LinesToCharsResult(chars1, chars2, lineArray);</span>
    }

    /**
     * Split a text into a list of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * @param text String to encode.
     * @param lineArray List of unique strings.
     * @param lineHash Map of strings to indices.
     * @return Encoded string.
     */
    private String diffLinesToCharsMunge(String text, List&lt;String&gt; lineArray,
                                         Map&lt;String, Integer&gt; lineHash) {
<span class="fc" id="L472">        int lineStart = 0;</span>
<span class="fc" id="L473">        int lineEnd = -1;</span>
        String line;
<span class="fc" id="L475">        StringBuilder chars = new StringBuilder();</span>
        // Walk the text, pulling out a substring for each line.
        // text.split('\n') would would temporarily double our memory footprint.
        // Modifying text would create many large strings to garbage collect.
<span class="fc bfc" id="L479" title="All 2 branches covered.">        while (lineEnd &lt; text.length() - 1) {</span>
<span class="fc" id="L480">            lineEnd = text.indexOf('\n', lineStart);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (lineEnd == -1) {</span>
<span class="fc" id="L482">                lineEnd = text.length() - 1;</span>
            }
<span class="fc" id="L484">            line = text.substring(lineStart, lineEnd + 1);</span>
<span class="fc" id="L485">            lineStart = lineEnd + 1;</span>

<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (lineHash.containsKey(line)) {</span>
<span class="fc" id="L488">                chars.append((char) (int) lineHash.get(line));</span>
            } else {
<span class="fc" id="L490">                lineArray.add(line);</span>
<span class="fc" id="L491">                lineHash.put(line, lineArray.size() - 1);</span>
<span class="fc" id="L492">                chars.append((char) (lineArray.size() - 1));</span>
            }
        }
<span class="fc" id="L495">        return chars.toString();</span>
    }

    /**
     * Rehydrate the text in a diff from a string of line hashes to real lines of
     * text.
     * @param diffs LinkedList of Diff objects.
     * @param lineArray List of unique strings.
     */
    protected void diffCharsToLines(List&lt;Diff&gt; diffs, List&lt;String&gt; lineArray) {
        StringBuilder text;
<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (Diff diff : diffs) {</span>
<span class="fc" id="L507">            text = new StringBuilder();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            for (int y = 0; y &lt; diff.getText().length(); y++) {</span>
<span class="fc" id="L509">                text.append(lineArray.get(diff.getText().charAt(y)));</span>
            }
<span class="fc" id="L511">            diff.setText(text.toString());</span>
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * Determine the common prefix of two strings
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the start of each string.
     */
    public int diffCommonPrefix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
<span class="fc" id="L523">        int n = Math.min(text1.length(), text2.length());</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">            if (text1.charAt(i) != text2.charAt(i)) {</span>
<span class="fc" id="L526">                return i;</span>
            }
        }
<span class="fc" id="L529">        return n;</span>
    }

    /**
     * Determine the common suffix of two strings
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the end of each string.
     */
    public int diffCommonSuffix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
<span class="fc" id="L540">        int text1Length = text1.length();</span>
<span class="fc" id="L541">        int text2Length = text2.length();</span>
<span class="fc" id="L542">        int n = Math.min(text1Length, text2Length);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (text1.charAt(text1Length - i) != text2.charAt(text2Length - i)) {</span>
<span class="fc" id="L545">                return i - 1;</span>
            }
        }
<span class="fc" id="L548">        return n;</span>
    }

    /**
     * Determine if the suffix of one string is the prefix of another.
     * @param valueText1 First string.
     * @param valueText2 Second string.
     * @return The number of characters common to the end of the first
     *     string and the start of the second string.
     */
    protected int diffCommonOverlap(String valueText1, String valueText2) {
<span class="fc" id="L559">        String text1 = valueText1;</span>
<span class="fc" id="L560">        String text2 = valueText2;</span>

        // Cache the text lengths to prevent multiple calls.
<span class="fc" id="L563">        int text1Length = text1.length();</span>
<span class="fc" id="L564">        int text2Length = text2.length();</span>
        // Eliminate the null case.
<span class="pc bpc" id="L566" title="2 of 4 branches missed.">        if (text1Length == 0 || text2Length == 0) {</span>
<span class="nc" id="L567">            return 0;</span>
        }
        // Truncate the longer string.
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (text1Length &gt; text2Length) {</span>
<span class="fc" id="L571">            text1 = text1.substring(text1Length - text2Length);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        } else if (text1Length &lt; text2Length) {</span>
<span class="fc" id="L573">            text2 = text2.substring(0, text1Length);</span>
        }
<span class="fc" id="L575">        int textLength = Math.min(text1Length, text2Length);</span>
        // Quick check for the worst case.
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (text1.equals(text2)) {</span>
<span class="nc" id="L578">            return textLength;</span>
        }

        // Start by looking for a single character match
        // and increase length until no match is found.
        // Performance analysis: http://neil.fraser.name/news/2010/11/04/
<span class="fc" id="L584">        int best = 0;</span>
<span class="fc" id="L585">        int length = 1;</span>
        while (true) {
<span class="fc" id="L587">            String pattern = text1.substring(textLength - length);</span>
<span class="fc" id="L588">            int found = text2.indexOf(pattern);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            if (found == -1) {</span>
<span class="fc" id="L590">                return best;</span>
            }
<span class="fc" id="L592">            length += found;</span>
<span class="pc bpc" id="L593" title="2 of 4 branches missed.">            if (found == 0 || text1.substring(textLength - length).equals(</span>
<span class="fc" id="L594">                    text2.substring(0, length))) {</span>
<span class="nc" id="L595">                best = length;</span>
<span class="nc" id="L596">                length++;</span>
            }
<span class="fc" id="L598">        }</span>
    }

    /**
     * Do the two texts share a substring which is at least half the length of
     * the longer text?
     * This speedup can produce non-minimal diffs.
     * @param text1 First string.
     * @param text2 Second string.
     * @return Five element String array, containing the prefix of text1, the
     *     suffix of text1, the prefix of text2, the suffix of text2 and the
     *     common middle.  Or null if there was no match.
     */
    protected String[] diffHalfMatch(String text1, String text2) {
<span class="fc bfc" id="L612" title="All 2 branches covered.">        String longtext = text1.length() &gt; text2.length() ? text1 : text2;</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">        String shorttext = text1.length() &gt; text2.length() ? text2 : text1;</span>
<span class="fc bfc" id="L614" title="All 4 branches covered.">        if (longtext.length() &lt; 4 || shorttext.length() * 2 &lt; longtext.length()) {</span>
<span class="fc" id="L615">            return null;  // Pointless.</span>
        }

        // First check if the second quarter is the seed for a half-match.
<span class="fc" id="L619">        String[] hm1 = this.diffHalfMatchI(longtext, shorttext, (longtext.length() + 3) / 4);</span>
        // Check again based on the third quarter.
<span class="fc" id="L621">        String[] hm2 = this.diffHalfMatchI(longtext, shorttext, (longtext.length() + 1) / 2);</span>
        String[] hm;
<span class="fc bfc" id="L623" title="All 4 branches covered.">        if (hm1 == null &amp;&amp; hm2 == null) {</span>
<span class="fc" id="L624">            return null;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        } else if (hm2 == null) {</span>
<span class="fc" id="L626">            hm = hm1;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        } else if (hm1 == null) {</span>
<span class="fc" id="L628">            hm = hm2;</span>
        } else {
            // Both matched.  Select the longest.
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            hm = hm1[4].length() &gt; hm2[4].length() ? hm1 : hm2;</span>
        }

        // A half-match was found, sort out the return data.
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (text1.length() &gt; text2.length()) {</span>
<span class="fc" id="L636">            return hm;</span>
        } else {
<span class="fc" id="L638">            return new String[]{hm[2], hm[3], hm[0], hm[1], hm[4]};</span>
        }
    }

    /**
     * Does a substring of shorttext exist within longtext such that the
     * substring is at least half the length of longtext?
     * @param longtext Longer string.
     * @param shorttext Shorter string.
     * @param i Start index of quarter length substring within longtext.
     * @return Five element String array, containing the prefix of longtext, the
     *     suffix of longtext, the prefix of shorttext, the suffix of shorttext
     *     and the common middle.  Or null if there was no match.
     */
    private String[] diffHalfMatchI(String longtext, String shorttext, int i) {
        // Start with a 1/4 length substring at position i as a seed.
<span class="fc" id="L654">        String seed = longtext.substring(i, i + longtext.length() / 4);</span>
<span class="fc" id="L655">        int j = -1;</span>
<span class="fc" id="L656">        String bestCommon = StringUtils.EMPTY;</span>
<span class="fc" id="L657">        String bestLongtextA = StringUtils.EMPTY;</span>
<span class="fc" id="L658">        String bestLongtextB = StringUtils.EMPTY;</span>
<span class="fc" id="L659">        String bestShorttextA = StringUtils.EMPTY;</span>
<span class="fc" id="L660">        String bestShorttextB = StringUtils.EMPTY;</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {</span>
<span class="fc" id="L662">            int prefixLength = this.diffCommonPrefix(longtext.substring(i),</span>
<span class="fc" id="L663">                    shorttext.substring(j));</span>
<span class="fc" id="L664">            int suffixLength = this.diffCommonSuffix(longtext.substring(0, i),</span>
<span class="fc" id="L665">                    shorttext.substring(0, j));</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (bestCommon.length() &lt; suffixLength + prefixLength) {</span>
<span class="fc" id="L667">                bestCommon = shorttext.substring(j - suffixLength, j)</span>
<span class="fc" id="L668">                        + shorttext.substring(j, j + prefixLength);</span>
<span class="fc" id="L669">                bestLongtextA = longtext.substring(0, i - suffixLength);</span>
<span class="fc" id="L670">                bestLongtextB = longtext.substring(i + prefixLength);</span>
<span class="fc" id="L671">                bestShorttextA = shorttext.substring(0, j - suffixLength);</span>
<span class="fc" id="L672">                bestShorttextB = shorttext.substring(j + prefixLength);</span>
            }
<span class="fc" id="L674">        }</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (bestCommon.length() * 2 &gt;= longtext.length()) {</span>
<span class="fc" id="L676">            return new String[]{bestLongtextA, bestLongtextB,</span>
                    bestShorttextA, bestShorttextB, bestCommon};
        } else {
<span class="fc" id="L679">            return null;</span>
        }
    }

    /**
     * Reduce the number of edits by eliminating semantically trivial equalities.
     * @param diffs LinkedList of Diff objects.
     */
    public void diffCleanupSemantic(LinkedList&lt;Diff&gt; diffs) {
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (diffs.isEmpty()) {</span>
<span class="nc" id="L689">            return;</span>
        }
<span class="fc" id="L691">        boolean changes = false;</span>
        // Synchronized Stack to avoid Exception
<span class="fc" id="L693">        Stack&lt;Diff&gt; equalities = new Stack&lt;&gt;();  // Stack of qualities.</span>
<span class="fc" id="L694">        String lastequality = null; // Always equal to equalities.lastElement().text</span>
<span class="fc" id="L695">        ListIterator&lt;Diff&gt; pointer = diffs.listIterator();</span>
        // Number of characters that changed prior to the equality.
<span class="fc" id="L697">        int lengthInsertions1 = 0;</span>
<span class="fc" id="L698">        int lengthDeletions1 = 0;</span>
        // Number of characters that changed after the equality.
<span class="fc" id="L700">        int lengthInsertions2 = 0;</span>
<span class="fc" id="L701">        int lengthDeletions2 = 0;</span>
<span class="fc" id="L702">        Diff thisDiff = pointer.next();</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        while (thisDiff != null) {</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">            if (thisDiff.getOperation() == Operation.EQUAL) {</span>
                // Equality found.
<span class="nc" id="L707">                equalities.push(thisDiff);</span>
<span class="nc" id="L708">                lengthInsertions1 = lengthInsertions2;</span>
<span class="nc" id="L709">                lengthDeletions1 = lengthDeletions2;</span>
<span class="nc" id="L710">                lengthInsertions2 = 0;</span>
<span class="nc" id="L711">                lengthDeletions2 = 0;</span>
<span class="nc" id="L712">                lastequality = thisDiff.getText();</span>
            } else {
                // An insertion or deletion.
<span class="fc bfc" id="L715" title="All 2 branches covered.">                if (thisDiff.getOperation() == Operation.INSERT) {</span>
<span class="fc" id="L716">                    lengthInsertions2 += thisDiff.getText().length();</span>
                } else {
<span class="fc" id="L718">                    lengthDeletions2 += thisDiff.getText().length();</span>
                }
                // Eliminate an equality that is smaller or equal to the edits on both
                // sides of it.
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                if (</span>
                        lastequality != null
<span class="nc bnc" id="L724" title="All 2 branches missed.">                                &amp;&amp; lastequality.length() &lt;= Math.max(lengthInsertions1, lengthDeletions1)</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                                &amp;&amp; lastequality.length() &lt;= Math.max(lengthInsertions2, lengthDeletions2)</span>
                ) {
                    // Walk back to offending equality.
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    while (thisDiff != equalities.lastElement()) {</span>
<span class="nc" id="L729">                        thisDiff = pointer.previous();</span>
                    }
<span class="nc" id="L731">                    pointer.next();</span>

                    // Replace equality with a delete.
<span class="nc" id="L734">                    pointer.set(new Diff(Operation.DELETE, lastequality));</span>
                    // Insert a corresponding an insert.
<span class="nc" id="L736">                    pointer.add(new Diff(Operation.INSERT, lastequality));</span>

<span class="nc" id="L738">                    equalities.pop();  // Throw away the equality we just deleted.</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                    if (!equalities.empty()) {</span>
                        // Throw away the previous equality (it needs to be reevaluated).
<span class="nc" id="L741">                        equalities.pop();</span>
                    }
<span class="nc bnc" id="L743" title="All 2 branches missed.">                    if (equalities.empty()) {</span>
                        // There are no previous equalities, walk back to the start.
<span class="nc bnc" id="L745" title="All 2 branches missed.">                        while (pointer.hasPrevious()) {</span>
<span class="nc" id="L746">                            pointer.previous();</span>
                        }
                    } else {
                        // There is a safe equality we can fall back to.
<span class="nc" id="L750">                        thisDiff = equalities.lastElement();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                        while (thisDiff != pointer.previous()) {</span>
                            // Intentionally empty loop.
                        }
                    }

<span class="nc" id="L756">                    lengthInsertions1 = 0;  // Reset the counters.</span>
<span class="nc" id="L757">                    lengthInsertions2 = 0;</span>
<span class="nc" id="L758">                    lengthDeletions1 = 0;</span>
<span class="nc" id="L759">                    lengthDeletions2 = 0;</span>
<span class="nc" id="L760">                    lastequality = null;</span>
<span class="nc" id="L761">                    changes = true;</span>
                }
            }
<span class="fc bfc" id="L764" title="All 2 branches covered.">            thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }

        // Normalize the diff.
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (changes) {</span>
<span class="nc" id="L769">            this.diffCleanupMerge(diffs);</span>
        }
<span class="fc" id="L771">        this.diffCleanupSemanticLossless(diffs);</span>

        // Find any overlaps between deletions and insertions.
        // e.g: &lt;del&gt;abcxxx&lt;/del&gt;&lt;ins&gt;xxxdef&lt;/ins&gt;
        //   -&gt; &lt;del&gt;abc&lt;/del&gt;xxx&lt;ins&gt;def&lt;/ins&gt;
        // e.g: &lt;del&gt;xxxabc&lt;/del&gt;&lt;ins&gt;defxxx&lt;/ins&gt;
        //   -&gt; &lt;ins&gt;def&lt;/ins&gt;xxx&lt;del&gt;abc&lt;/del&gt;
        // Only extract an overlap if it is as big as the edit ahead or behind it.
<span class="fc" id="L779">        pointer = diffs.listIterator();</span>
<span class="fc" id="L780">        Diff prevDiff = null;</span>
<span class="fc" id="L781">        thisDiff = null;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (pointer.hasNext()) {</span>
<span class="fc" id="L783">            prevDiff = pointer.next();</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">            if (pointer.hasNext()) {</span>
<span class="fc" id="L785">                thisDiff = pointer.next();</span>
            }
        }

<span class="fc bfc" id="L789" title="All 2 branches covered.">        while (thisDiff != null) {</span>
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">            if (prevDiff.getOperation() == Operation.DELETE &amp;&amp;</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                    thisDiff.getOperation() == Operation.INSERT) {</span>
<span class="fc" id="L792">                String deletion = prevDiff.getText();</span>
<span class="fc" id="L793">                String insertion = thisDiff.getText();</span>
<span class="fc" id="L794">                int overlapLength1 = this.diffCommonOverlap(deletion, insertion);</span>
<span class="fc" id="L795">                int overlapLength2 = this.diffCommonOverlap(insertion, deletion);</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                if (overlapLength1 &gt;= overlapLength2) {</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                    if (overlapLength1 &gt;= deletion.length() / 2.0 ||</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">                            overlapLength1 &gt;= insertion.length() / 2.0) {</span>
                        // Overlap found.  Insert an equality and trim the surrounding edits.
<span class="nc" id="L800">                        pointer.previous();</span>
<span class="nc" id="L801">                        pointer.add(new Diff(Operation.EQUAL,</span>
<span class="nc" id="L802">                                insertion.substring(0, overlapLength1)));</span>
<span class="nc" id="L803">                        prevDiff.setText(deletion.substring(0, deletion.length() - overlapLength1));</span>
<span class="nc" id="L804">                        thisDiff.setText(insertion.substring(overlapLength1));</span>
                        // pointer.add inserts the element before the cursor, so there is
                        // no need to step past the new element.
                    }
                } else {
<span class="nc bnc" id="L809" title="All 2 branches missed.">                    if (overlapLength2 &gt;= deletion.length() / 2.0 ||</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                            overlapLength2 &gt;= insertion.length() / 2.0) {</span>
                        // Reverse overlap found.
                        // Insert an equality and swap and trim the surrounding edits.
<span class="nc" id="L813">                        pointer.previous();</span>
<span class="nc" id="L814">                        pointer.add(new Diff(Operation.EQUAL,</span>
<span class="nc" id="L815">                                deletion.substring(0, overlapLength2)));</span>
<span class="nc" id="L816">                        prevDiff.setOperation(Operation.INSERT);</span>
<span class="nc" id="L817">                        prevDiff.setText(insertion.substring(0, insertion.length() - overlapLength2));</span>
<span class="nc" id="L818">                        thisDiff.setOperation(Operation.DELETE);</span>
<span class="nc" id="L819">                        thisDiff.setText(deletion.substring(overlapLength2));</span>
                        // pointer.add inserts the element before the cursor, so there is
                        // no need to step past the new element.
                    }
                }
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">                thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
            }
<span class="fc" id="L826">            prevDiff = thisDiff;</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">            thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }
<span class="fc" id="L829">    }</span>

    /**
     * Look for single edits surrounded on both sides by equalities
     * which can be shifted sideways to align the edit to a word boundary.
     * e.g: The c&lt;ins&gt;at c&lt;/ins&gt;ame. -&gt; The &lt;ins&gt;cat &lt;/ins&gt;came.
     * @param diffs LinkedList of Diff objects.
     */
    public void diffCleanupSemanticLossless(List&lt;Diff&gt; diffs) {
<span class="fc" id="L838">        StringBuilder equality1 = new StringBuilder();</span>
        String edit;
<span class="fc" id="L840">        StringBuilder equality2 = new StringBuilder();</span>
        String commonString;
        int commonOffset;
        int score;
        int bestScore;
        String bestEquality1;
        String bestEdit;
        String bestEquality2;
        // Create a new iterator at the start.
<span class="fc" id="L849">        ListIterator&lt;Diff&gt; pointer = diffs.listIterator();</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">        Diff prevDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        Diff thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">        Diff nextDiff = pointer.hasNext() ? pointer.next() : null;</span>

        // Intentionally ignore the first and last element (don't need checking).
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">        while (nextDiff != null) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (prevDiff.getOperation() == Operation.EQUAL &amp;&amp;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">                    nextDiff.getOperation() == Operation.EQUAL) {</span>
                // This is a single edit surrounded by equalities.
<span class="nc" id="L859">                equality1.setLength(0);</span>
<span class="nc" id="L860">                equality1.append(prevDiff.getText());</span>
<span class="nc" id="L861">                edit = thisDiff.getText();</span>
<span class="nc" id="L862">                equality2.setLength(0);</span>
<span class="nc" id="L863">                equality2.append(nextDiff.getText());</span>

                // First, shift the edit as far left as possible.
<span class="nc" id="L866">                commonOffset = this.diffCommonSuffix(equality1.toString(), edit);</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (commonOffset != 0) {</span>
<span class="nc" id="L868">                    commonString = edit.substring(edit.length() - commonOffset);</span>
<span class="nc" id="L869">                    String substring = equality1.substring(0, equality1.length() - commonOffset);</span>
<span class="nc" id="L870">                    equality1.setLength(0);</span>
<span class="nc" id="L871">                    equality1.append(substring);</span>
<span class="nc" id="L872">                    edit = commonString + edit.substring(0, edit.length() - commonOffset);</span>
<span class="nc" id="L873">                    equality2.insert(0, commonString);</span>
                }

                // Second, step character by character right, looking for the best fit.
<span class="nc" id="L877">                bestEquality1 = equality1.toString();</span>
<span class="nc" id="L878">                bestEdit = edit;</span>
<span class="nc" id="L879">                bestEquality2 = equality2.toString();</span>
<span class="nc" id="L880">                bestScore = this.diffCleanupSemanticScore(equality1.toString(), edit)</span>
<span class="nc" id="L881">                        + this.diffCleanupSemanticScore(edit, equality2.toString());</span>
<span class="nc bnc" id="L882" title="All 4 branches missed.">                while (!edit.isEmpty() &amp;&amp; !equality2.isEmpty()</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                        &amp;&amp; edit.charAt(0) == equality2.charAt(0)) {</span>
<span class="nc" id="L884">                    equality1.append(edit.charAt(0));</span>
<span class="nc" id="L885">                    edit = edit.substring(1) + equality2.charAt(0);</span>
<span class="nc" id="L886">                    String substring = equality2.substring(1);</span>
<span class="nc" id="L887">                    equality2.setLength(0);</span>
<span class="nc" id="L888">                    equality2.append(substring);</span>
<span class="nc" id="L889">                    score = this.diffCleanupSemanticScore(equality1.toString(), edit)</span>
<span class="nc" id="L890">                            + this.diffCleanupSemanticScore(edit, equality2.toString());</span>
                    // The &gt;= encourages trailing rather than leading whitespace on edits.
<span class="nc bnc" id="L892" title="All 2 branches missed.">                    if (score &gt;= bestScore) {</span>
<span class="nc" id="L893">                        bestScore = score;</span>
<span class="nc" id="L894">                        bestEquality1 = equality1.toString();</span>
<span class="nc" id="L895">                        bestEdit = edit;</span>
<span class="nc" id="L896">                        bestEquality2 = equality2.toString();</span>
                    }
<span class="nc" id="L898">                }</span>

<span class="nc bnc" id="L900" title="All 2 branches missed.">                if (!prevDiff.getText().equals(bestEquality1)) {</span>
                    // We have an improvement, save it back to the diff.
<span class="nc bnc" id="L902" title="All 2 branches missed.">                    if (!bestEquality1.isEmpty()) {</span>
<span class="nc" id="L903">                        prevDiff.setText(bestEquality1);</span>
                    } else {
<span class="nc" id="L905">                        pointer.previous(); // Walk past nextDiff.</span>
<span class="nc" id="L906">                        pointer.previous(); // Walk past thisDiff.</span>
<span class="nc" id="L907">                        pointer.previous(); // Walk past prevDiff.</span>
<span class="nc" id="L908">                        pointer.remove(); // Delete prevDiff.</span>
<span class="nc" id="L909">                        pointer.next(); // Walk past thisDiff.</span>
<span class="nc" id="L910">                        pointer.next(); // Walk past nextDiff.</span>
                    }
<span class="nc" id="L912">                    thisDiff.setText(bestEdit);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                    if (!bestEquality2.isEmpty()) {</span>
<span class="nc" id="L914">                        nextDiff.setText(bestEquality2);</span>
                    } else {
<span class="nc" id="L916">                        pointer.remove(); // Delete nextDiff.</span>
<span class="nc" id="L917">                        nextDiff = thisDiff;</span>
<span class="nc" id="L918">                        thisDiff = prevDiff;</span>
                    }
                }
            }
<span class="nc" id="L922">            prevDiff = thisDiff;</span>
<span class="nc" id="L923">            thisDiff = nextDiff;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            nextDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }
<span class="fc" id="L926">    }</span>

    /**
     * Given two strings, compute a score representing whether the internal
     * boundary falls on logical boundaries.
     * Scores range from 6 (best) to 0 (worst).
     * @param one First string.
     * @param two Second string.
     * @return The score.
     */
    private int diffCleanupSemanticScore(String one, String two) {
<span class="nc bnc" id="L937" title="All 4 branches missed.">        if (one.isEmpty() || two.isEmpty()) {</span>
            // Edges are the best.
<span class="nc" id="L939">            return 6;</span>
        }

        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'.  Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
<span class="nc" id="L947">        char char1 = one.charAt(one.length() - 1);</span>
<span class="nc" id="L948">        char char2 = two.charAt(0);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">        boolean nonAlphaNumeric1 = !Character.isLetterOrDigit(char1);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        boolean nonAlphaNumeric2 = !Character.isLetterOrDigit(char2);</span>
<span class="nc bnc" id="L951" title="All 4 branches missed.">        boolean whitespace1 = nonAlphaNumeric1 &amp;&amp; Character.isWhitespace(char1);</span>
<span class="nc bnc" id="L952" title="All 4 branches missed.">        boolean whitespace2 = nonAlphaNumeric2 &amp;&amp; Character.isWhitespace(char2);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">        boolean lineBreak1 = whitespace1</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                &amp;&amp; Character.getType(char1) == Character.CONTROL;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        boolean lineBreak2 = whitespace2</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                &amp;&amp; Character.getType(char2) == Character.CONTROL;</span>
<span class="nc bnc" id="L957" title="All 4 branches missed.">        boolean blankLine1 = lineBreak1 &amp;&amp; DiffMatchPatch.BLANK_LINE_END.matcher(one).find();</span>
<span class="nc bnc" id="L958" title="All 4 branches missed.">        boolean blankLine2 = lineBreak2 &amp;&amp; DiffMatchPatch.BLANK_LINE_START.matcher(two).find();</span>

<span class="nc bnc" id="L960" title="All 4 branches missed.">        if (blankLine1 || blankLine2) {</span>
            // Five points for blank lines.
<span class="nc" id="L962">            return 5;</span>
<span class="nc bnc" id="L963" title="All 4 branches missed.">        } else if (lineBreak1 || lineBreak2) {</span>
            // Four points for line breaks.
<span class="nc" id="L965">            return 4;</span>
<span class="nc bnc" id="L966" title="All 6 branches missed.">        } else if (nonAlphaNumeric1 &amp;&amp; !whitespace1 &amp;&amp; whitespace2) {</span>
            // Three points for end of sentences.
<span class="nc" id="L968">            return 3;</span>
<span class="nc bnc" id="L969" title="All 4 branches missed.">        } else if (whitespace1 || whitespace2) {</span>
            // Two points for whitespace.
<span class="nc" id="L971">            return 2;</span>
<span class="nc bnc" id="L972" title="All 4 branches missed.">        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {</span>
            // One point for non-alphanumeric.
<span class="nc" id="L974">            return 1;</span>
        }
<span class="nc" id="L976">        return 0;</span>
    }

    /**
     * Reduce the number of edits by eliminating operationally trivial equalities.
     * @param diffs LinkedList of Diff objects.
     */
    public void diffCleanupEfficiency(LinkedList&lt;Diff&gt; diffs) {
<span class="fc bfc" id="L984" title="All 2 branches covered.">        if (diffs.isEmpty()) {</span>
<span class="fc" id="L985">            return;</span>
        }
<span class="fc" id="L987">        boolean changes = false;</span>
        // Synchronized Stack to avoid Exception
<span class="fc" id="L989">        Stack&lt;Diff&gt; equalities = new Stack&lt;&gt;();  // Stack of equalities.</span>
<span class="fc" id="L990">        String lastequality = null; // Always equal to equalities.lastElement().text</span>
<span class="fc" id="L991">        ListIterator&lt;Diff&gt; pointer = diffs.listIterator();</span>
        // Is there an insertion operation before the last equality.
<span class="fc" id="L993">        boolean preIns = false;</span>
        // Is there a deletion operation before the last equality.
<span class="fc" id="L995">        boolean preDel = false;</span>
        // Is there an insertion operation after the last equality.
<span class="fc" id="L997">        boolean postIns = false;</span>
        // Is there a deletion operation after the last equality.
<span class="fc" id="L999">        boolean postDel = false;</span>
<span class="fc" id="L1000">        Diff thisDiff = pointer.next();</span>
<span class="fc" id="L1001">        Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        while (thisDiff != null) {</span>

<span class="fc bfc" id="L1004" title="All 2 branches covered.">            if (thisDiff.getOperation() == Operation.EQUAL) {</span>

                // Equality found.
<span class="fc bfc" id="L1007" title="All 6 branches covered.">                if (thisDiff.getText().length() &lt; DiffMatchPatch.DIFF_EDIT_COST &amp;&amp; (postIns || postDel)) {</span>
                    // Candidate found.
<span class="fc" id="L1009">                    equalities.push(thisDiff);</span>
<span class="fc" id="L1010">                    preIns = postIns;</span>
<span class="fc" id="L1011">                    preDel = postDel;</span>
<span class="fc" id="L1012">                    lastequality = thisDiff.getText();</span>
                } else {
                    // Not a candidate, and can never become one.
<span class="fc" id="L1015">                    equalities.clear();</span>
<span class="fc" id="L1016">                    lastequality = null;</span>
<span class="fc" id="L1017">                    safeDiff = thisDiff;</span>
                }
<span class="fc" id="L1019">                postIns = postDel = false;</span>
            } else {
                // An insertion or deletion.
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                if (thisDiff.getOperation() == Operation.DELETE) {</span>
<span class="fc" id="L1023">                    postDel = true;</span>
                } else {
<span class="fc" id="L1025">                    postIns = true;</span>
                }

                /*
                 * Five types to be split:
                 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;XY&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                 * &lt;ins&gt;A&lt;/ins&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;
                 * &lt;ins&gt;A&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                 * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;del&gt;C&lt;/del&gt;
                 */
<span class="fc bfc" id="L1036" title="All 10 branches covered.">                if (</span>
                        lastequality != null
                                &amp;&amp; (
                                (preIns &amp;&amp; preDel &amp;&amp; postIns &amp;&amp; postDel)
                                        || (
<span class="fc bfc" id="L1041" title="All 2 branches covered.">                                        (lastequality.length() &lt; DiffMatchPatch.DIFF_EDIT_COST / 2)</span>
<span class="fc bfc" id="L1042" title="All 10 branches covered.">                                                &amp;&amp; ((preIns ? 1 : 0) + (preDel ? 1 : 0) + (postIns ? 1 : 0) + (postDel ? 1 : 0)) == 3</span>
                                )
                        )
                ) {
                    // Walk back to offending equality.
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                    while (thisDiff != equalities.lastElement()) {</span>
<span class="fc" id="L1048">                        thisDiff = pointer.previous();</span>
                    }
<span class="fc" id="L1050">                    pointer.next();</span>

                    // Replace equality with a delete.
<span class="fc" id="L1053">                    pointer.set(new Diff(Operation.DELETE, lastequality));</span>
                    // Insert a corresponding an insert.
<span class="fc" id="L1055">                    thisDiff = new Diff(Operation.INSERT, lastequality);</span>
<span class="fc" id="L1056">                    pointer.add(thisDiff);</span>

<span class="fc" id="L1058">                    equalities.pop();  // Throw away the equality we just deleted.</span>
<span class="fc" id="L1059">                    lastequality = null;</span>
<span class="fc bfc" id="L1060" title="All 4 branches covered.">                    if (preIns &amp;&amp; preDel) {</span>
                        // No changes made which could affect previous entry, keep going.
<span class="fc" id="L1062">                        postIns = postDel = true;</span>
<span class="fc" id="L1063">                        equalities.clear();</span>
<span class="fc" id="L1064">                        safeDiff = thisDiff;</span>
                    } else {
<span class="fc bfc" id="L1066" title="All 2 branches covered.">                        if (!equalities.empty()) {</span>
                            // Throw away the previous equality (it needs to be reevaluated).
<span class="fc" id="L1068">                            equalities.pop();</span>
                        }
<span class="fc bfc" id="L1070" title="All 2 branches covered.">                        if (equalities.empty()) {</span>
                            // There are no previous questionable equalities,
                            // walk back to the last known safe diff.
<span class="fc" id="L1073">                            thisDiff = safeDiff;</span>
                        } else {
                            // There is an equality we can fall back to.
<span class="fc" id="L1076">                            thisDiff = equalities.lastElement();</span>
                        }
<span class="fc bfc" id="L1078" title="All 2 branches covered.">                        while (thisDiff != pointer.previous()) {</span>
                            // Intentionally empty loop.
                        }
<span class="fc" id="L1081">                        postIns = postDel = false;</span>
                    }

<span class="fc" id="L1084">                    changes = true;</span>
                }
            }
<span class="fc bfc" id="L1087" title="All 2 branches covered.">            thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }

<span class="fc bfc" id="L1090" title="All 2 branches covered.">        if (changes) {</span>
<span class="fc" id="L1091">            this.diffCleanupMerge(diffs);</span>
        }
<span class="fc" id="L1093">    }</span>

    /**
     * Reorder and merge like edit sections.  Merge equalities.
     * Any edit section can move as long as it doesn't cross an equality.
     * @param diffs LinkedList of Diff objects.
     */
    public void diffCleanupMerge(LinkedList&lt;Diff&gt; diffs) {
<span class="fc" id="L1101">        diffs.add(new Diff(Operation.EQUAL, StringUtils.EMPTY));  // Add a dummy entry at the end.</span>
<span class="fc" id="L1102">        ListIterator&lt;Diff&gt; pointer = diffs.listIterator();</span>
<span class="fc" id="L1103">        int countDelete = 0;</span>
<span class="fc" id="L1104">        int countInsert = 0;</span>
<span class="fc" id="L1105">        StringBuilder textDelete = new StringBuilder();</span>
<span class="fc" id="L1106">        StringBuilder textInsert = new StringBuilder();</span>
<span class="fc" id="L1107">        Diff thisDiff = pointer.next();</span>
<span class="fc" id="L1108">        Diff prevEqual = null;</span>
        int commonlength;
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        while (thisDiff != null) {</span>
<span class="pc bpc" id="L1111" title="1 of 4 branches missed.">            switch (thisDiff.getOperation()) {</span>
                case INSERT:
<span class="fc" id="L1113">                    countInsert++;</span>
<span class="fc" id="L1114">                    textInsert.append(thisDiff.getText());</span>
<span class="fc" id="L1115">                    prevEqual = null;</span>
<span class="fc" id="L1116">                    break;</span>
                case DELETE:
<span class="fc" id="L1118">                    countDelete++;</span>
<span class="fc" id="L1119">                    textDelete.append(thisDiff.getText());</span>
<span class="fc" id="L1120">                    prevEqual = null;</span>
<span class="fc" id="L1121">                    break;</span>
                case EQUAL:
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                    if (countDelete + countInsert &gt; 1) {</span>

<span class="fc bfc" id="L1125" title="All 4 branches covered.">                        boolean bothTypes = countDelete != 0 &amp;&amp; countInsert != 0;</span>
                        // Delete the offending records.
<span class="fc" id="L1127">                        pointer.previous();  // Reverse direction.</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">                        while (countDelete-- &gt; 0) {</span>
<span class="fc" id="L1129">                            pointer.previous();</span>
<span class="fc" id="L1130">                            pointer.remove();</span>
                        }
<span class="fc bfc" id="L1132" title="All 2 branches covered.">                        while (countInsert-- &gt; 0) {</span>
<span class="fc" id="L1133">                            pointer.previous();</span>
<span class="fc" id="L1134">                            pointer.remove();</span>
                        }

<span class="fc bfc" id="L1137" title="All 2 branches covered.">                        if (bothTypes) {</span>
                            // Factor out any common prefixies.
<span class="fc" id="L1139">                            commonlength = this.diffCommonPrefix(textInsert.toString(), textDelete.toString());</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">                            if (commonlength != 0) {</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                                if (pointer.hasPrevious()) {</span>
<span class="nc" id="L1142">                                    thisDiff = pointer.previous();</span>
                                    // Previous diff should have been an equality: thisDiff.getOperation() == Operation.EQUAL&quot;)
<span class="nc" id="L1144">                                    thisDiff.setText(thisDiff.getText() + textInsert.substring(0, commonlength));</span>
<span class="nc" id="L1145">                                    pointer.next();</span>
                                } else {
<span class="nc" id="L1147">                                    pointer.add(new Diff(Operation.EQUAL,</span>
<span class="nc" id="L1148">                                            textInsert.substring(0, commonlength)));</span>
                                }
<span class="nc" id="L1150">                                String substringIns = textInsert.substring(commonlength);</span>
<span class="nc" id="L1151">                                textInsert.setLength(0);</span>
<span class="nc" id="L1152">                                textInsert.append(substringIns);</span>
<span class="nc" id="L1153">                                String substringDel = textDelete.substring(commonlength);</span>
<span class="nc" id="L1154">                                textDelete.setLength(0);</span>
<span class="nc" id="L1155">                                textDelete.append(substringDel);</span>
                            }
                            // Factor out any common suffixies.
<span class="fc" id="L1158">                            commonlength = this.diffCommonSuffix(textInsert.toString(), textDelete.toString());</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">                            if (commonlength != 0) {</span>
<span class="nc" id="L1160">                                thisDiff = pointer.next();</span>
<span class="nc" id="L1161">                                thisDiff.setText(textInsert.substring(textInsert.length() - commonlength) + thisDiff.getText());</span>
<span class="nc" id="L1162">                                String substringIns = textInsert.substring(0, textInsert.length() - commonlength);</span>
<span class="nc" id="L1163">                                textInsert.setLength(0);</span>
<span class="nc" id="L1164">                                textInsert.append(substringIns);</span>
<span class="nc" id="L1165">                                String substringDel = textDelete.substring(0, textDelete.length() - commonlength);</span>
<span class="nc" id="L1166">                                textDelete.setLength(0);</span>
<span class="nc" id="L1167">                                textDelete.append(substringDel);</span>
<span class="nc" id="L1168">                                pointer.previous();</span>
                            }
                        }
                        // Insert the merged records.
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                        if (!textDelete.isEmpty()) {</span>
<span class="fc" id="L1173">                            pointer.add(new Diff(Operation.DELETE, textDelete.toString()));</span>
                        }
<span class="fc bfc" id="L1175" title="All 2 branches covered.">                        if (!textInsert.isEmpty()) {</span>
<span class="fc" id="L1176">                            pointer.add(new Diff(Operation.INSERT, textInsert.toString()));</span>
                        }
                        // Step forward to the equality.
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">                        thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">                    } else if (prevEqual != null) {</span>
                        // Merge this equality with the previous one.
<span class="fc" id="L1182">                        prevEqual.setText(prevEqual.getText() + thisDiff.getText());</span>
<span class="fc" id="L1183">                        pointer.remove();</span>
<span class="fc" id="L1184">                        thisDiff = pointer.previous();</span>
<span class="fc" id="L1185">                        pointer.next();  // Forward direction</span>
                    }
<span class="fc" id="L1187">                    countInsert = 0;</span>
<span class="fc" id="L1188">                    countDelete = 0;</span>
<span class="fc" id="L1189">                    textDelete.setLength(0);</span>
<span class="fc" id="L1190">                    textInsert.setLength(0);</span>
<span class="fc" id="L1191">                    prevEqual = thisDiff;</span>
                    break;
            }
<span class="fc bfc" id="L1194" title="All 2 branches covered.">            thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }
<span class="fc bfc" id="L1196" title="All 2 branches covered.">        if (diffs.getLast().getText().isEmpty()) {</span>
<span class="fc" id="L1197">            diffs.removeLast();  // Remove the dummy entry at the end.</span>
        }

        /*
         * Second pass: look for single edits surrounded on both sides by equalities
         * which can be shifted sideways to eliminate an equality.
         * e.g: A&lt;ins&gt;BA&lt;/ins&gt;C -&gt; &lt;ins&gt;AB&lt;/ins&gt;AC
         */
<span class="fc" id="L1205">        boolean changes = false;</span>
        // Create a new iterator at the start.
        // (As opposed to walking the current one back.)
<span class="fc" id="L1208">        pointer = diffs.listIterator();</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        Diff prevDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        thisDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        Diff nextDiff = pointer.hasNext() ? pointer.next() : null;</span>

        // Intentionally ignore the first and last element (don't need checking).
<span class="fc bfc" id="L1214" title="All 2 branches covered.">        while (nextDiff != null) {</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">            if (prevDiff.getOperation() == Operation.EQUAL &amp;&amp;</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">                    nextDiff.getOperation() == Operation.EQUAL) {</span>
                // This is a single edit surrounded by equalities.
<span class="fc bfc" id="L1218" title="All 2 branches covered.">                if (thisDiff.getText().endsWith(prevDiff.getText())) {</span>
                    // Shift the edit over the previous equality.
<span class="fc" id="L1220">                    thisDiff.setText(prevDiff.getText()</span>
<span class="fc" id="L1221">                            + thisDiff.getText().substring(0, thisDiff.getText().length()</span>
<span class="fc" id="L1222">                            - prevDiff.getText().length()));</span>
<span class="fc" id="L1223">                    nextDiff.setText(prevDiff.getText() + nextDiff.getText());</span>
<span class="fc" id="L1224">                    pointer.previous(); // Walk past nextDiff.</span>
<span class="fc" id="L1225">                    pointer.previous(); // Walk past thisDiff.</span>
<span class="fc" id="L1226">                    pointer.previous(); // Walk past prevDiff.</span>
<span class="fc" id="L1227">                    pointer.remove(); // Delete prevDiff.</span>
<span class="fc" id="L1228">                    pointer.next(); // Walk past thisDiff.</span>
<span class="fc" id="L1229">                    thisDiff = pointer.next(); // Walk past nextDiff.</span>
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">                    nextDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="fc" id="L1231">                    changes = true;</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                } else if (thisDiff.getText().startsWith(nextDiff.getText())) {</span>
                    // Shift the edit over the next equality.
<span class="fc" id="L1234">                    prevDiff.setText(prevDiff.getText() + nextDiff.getText());</span>
<span class="fc" id="L1235">                    thisDiff.setText(thisDiff.getText().substring(nextDiff.getText().length())</span>
<span class="fc" id="L1236">                            + nextDiff.getText());</span>
<span class="fc" id="L1237">                    pointer.remove(); // Delete nextDiff.</span>
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">                    nextDiff = pointer.hasNext() ? pointer.next() : null;</span>
<span class="fc" id="L1239">                    changes = true;</span>
                }
            }
<span class="fc" id="L1242">            prevDiff = thisDiff;</span>
<span class="fc" id="L1243">            thisDiff = nextDiff;</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">            nextDiff = pointer.hasNext() ? pointer.next() : null;</span>
        }
        // If shifts were made, the diff needs reordering and another shift sweep.
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (changes) {</span>
<span class="fc" id="L1248">            this.diffCleanupMerge(diffs);</span>
        }
<span class="fc" id="L1250">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>