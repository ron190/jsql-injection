<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseNCodec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.util.bruter</a> &gt; <span class="el_source">BaseNCodec.java</span></div><h1>BaseNCodec.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jsql.util.bruter;

import org.apache.commons.codec.BinaryDecoder;
import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.apache.commons.codec.binary.StringUtils;

import java.util.Arrays;
import java.util.Objects;

/**
 * Abstract superclass for Base-N encoders and decoders.
 *
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a valid
 * encoding. These can be bits that are unused from the final character or entire characters. The default mode is
 * lenient decoding.
 * &lt;ul&gt;
 * &lt;li&gt;Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.
 * &lt;li&gt;Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid
 * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not
 * allowed.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches
 * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding
 * and alphabet as the encoder.
 * &lt;/p&gt;
 */
public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {

    /**
     * EOF
     *
     * @since 1.7
     */
    private static final int EOF = -1;

    /**
     *  MIME chunk size per RFC 2045 section 6.8.
     *
     * &lt;p&gt;
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * &lt;/p&gt;
     *
     * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045 section 6.8&lt;/a&gt;
     */
    public static final int MIME_CHUNK_SIZE = 76;

    /**
     * PEM chunk size per RFC 1421 section 4.3.2.4.
     *
     * &lt;p&gt;
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * &lt;/p&gt;
     *
     * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc1421&quot;&gt;RFC 1421 section 4.3.2.4&lt;/a&gt;
     */
    public static final int PEM_CHUNK_SIZE = 64;

    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;

    /**
     * Defines the default buffer size - currently {@value}
     * - must be large enough for at least one encoded block+separator
     */
    private static final int DEFAULT_BUFFER_SIZE = 8192;

    /**
     * The maximum size buffer to allocate.
     *
     * &lt;p&gt;This is set to the same size used in the JDK {@code java.util.ArrayList}:&lt;/p&gt;
     * &lt;blockquote&gt;
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit.
     * &lt;/blockquote&gt;
     */
    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;

    /** Mask used to extract 8 bits, used in decoding bytes */
    protected static final int MASK_8BITS = 0xff;

    /**
     * Byte used to pad output.
     */
    protected static final byte PAD_DEFAULT = '='; // Allow static access to default

    /**
     * The default decoding policy.
     * @since 1.15
     */
<span class="fc" id="L116">    protected static final CodecPolicy DECODING_POLICY_DEFAULT = CodecPolicy.LENIENT;</span>

    /**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045 section 2.1&lt;/a&gt;
     */
<span class="fc" id="L123">    private static final byte[] CHUNK_SEPARATOR = {'\r', '\n'};</span>

    protected final byte pad; // instance variable just in case it needs to vary later

    /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */
    private final int unencodedBlockSize;

    /** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */
    private final int encodedBlockSize;

    /**
     * Chunksize for encoding. Not used when decoding.
     * A value of zero or less implies no chunking of the encoded data.
     * Rounded down to nearest multiple of encodedBlockSize.
     */
    protected final int lineLength;

    /**
     * Size of chunk separator. Not used unless {@link #lineLength} &amp;gt; 0.
     */
    private final int chunkSeparatorLength;

    /**
     * Defines the decoding behavior when the input bytes contain leftover trailing bits that
     * cannot be created by a valid encoding. These can be bits that are unused from the final
     * character or entire characters. The default mode is lenient decoding. Set this to
     * {@code true} to enable strict decoding.
     * &lt;ul&gt;
     * &lt;li&gt;Lenient: Any trailing bits are composed into 8-bit bytes where possible.
     *     The remainder are discarded.
     * &lt;li&gt;Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits
     *     are not part of a valid encoding. Any unused bits from the final character must
     *     be zero. Impossible counts of entire final characters are not allowed.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;When strict decoding is enabled it is expected that the decoded bytes will be re-encoded
     * to a byte array that matches the original, i.e. no changes occur on the final
     * character. This requires that the input bytes use the same padding and alphabet
     * as the encoder.
     */
    private final CodecPolicy decodingPolicy;

    /**
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)
     * @param lineLength if &amp;gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant
     */
    protected BaseNCodec(
        final int unencodedBlockSize,
        final int encodedBlockSize,
        final int lineLength,
        final int chunkSeparatorLength
    ) {
<span class="nc" id="L179">        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, BaseNCodec.PAD_DEFAULT);</span>
<span class="nc" id="L180">    }</span>

    /**
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)
     * @param lineLength if &amp;gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant
     * @param pad byte used as padding byte.
     */
    protected BaseNCodec(
        final int unencodedBlockSize,
        final int encodedBlockSize,
        final int lineLength,
        final int chunkSeparatorLength,
        final byte pad
    ) {
<span class="nc" id="L198">        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, pad, BaseNCodec.DECODING_POLICY_DEFAULT);</span>
<span class="nc" id="L199">    }</span>

    /**
     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.
     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.
     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)
     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)
     * @param lineLength if &amp;gt; 0, use chunking with a length {@code lineLength}
     * @param chunkSeparatorLength the chunk separator length, if relevant
     * @param pad byte used as padding byte.
     * @param decodingPolicy Decoding policy.
     * @since 1.15
     */
    protected BaseNCodec(
        final int unencodedBlockSize,
        final int encodedBlockSize,
        final int lineLength,
        final int chunkSeparatorLength,
        final byte pad,
        final CodecPolicy decodingPolicy
<span class="fc" id="L219">    ) {</span>
<span class="fc" id="L220">        this.unencodedBlockSize = unencodedBlockSize;</span>
<span class="fc" id="L221">        this.encodedBlockSize = encodedBlockSize;</span>
<span class="pc bpc" id="L222" title="3 of 4 branches missed.">        final boolean useChunking = lineLength &gt; 0 &amp;&amp; chunkSeparatorLength &gt; 0;</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        this.lineLength = useChunking ? lineLength / encodedBlockSize * encodedBlockSize : 0;</span>
<span class="fc" id="L224">        this.chunkSeparatorLength = chunkSeparatorLength;</span>
<span class="fc" id="L225">        this.pad = pad;</span>
<span class="fc" id="L226">        this.decodingPolicy = Objects.requireNonNull(decodingPolicy, &quot;codecPolicy&quot;);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Compares two {@code int} values numerically treating the values
     * as unsigned. Taken from JDK 1.8.
     *
     * @param  x the first {@code int} to compare
     * @param  y the second {@code int} to compare
     * @return the value {@code 0} if {@code x == y}; a value less
     *         than {@code 0} if {@code x &lt; y} as unsigned values; and
     *         a value greater than {@code 0} if {@code x &gt; y} as
     *         unsigned values
     */
    private static int compareUnsigned(final int x, final int y) {
<span class="nc" id="L241">        return Integer.compare(x + Integer.MIN_VALUE, y + Integer.MIN_VALUE);</span>
    }

    /**
     * Create a positive capacity at least as large the minimum required capacity.
     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array
     * can be allocated.
     *
     * @param minCapacity the minimum capacity
     * @return the capacity
     * @throws OutOfMemoryError if the {@code minCapacity} is negative
     */
    private static int createPositiveCapacity(final int minCapacity) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (minCapacity &lt; 0) {</span>
            // overflow
<span class="nc" id="L256">            throw new OutOfMemoryError(&quot;Unable to allocate array size: &quot; + (minCapacity &amp; 0xffffffffL));</span>
        }
        // This is called when we require buffer expansion to a very big array.
        // Use the conservative maximum buffer size if possible, otherwise the biggest required.
        //
        // Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE.
        // This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full
        // Integer.MAX_VALUE length array.
        // The result is that we may have to allocate an array of this size more than once if
        // the capacity must be expanded again.
<span class="nc" id="L266">        return Math.max(minCapacity, BaseNCodec.MAX_BUFFER_SIZE);</span>
    }

    /**
     * Gets a copy of the chunk separator per RFC 2045 section 2.1.
     *
     * @return the chunk separator
     * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045 section 2.1&lt;/a&gt;
     * @since 1.15
     */
    public static byte[] getChunkSeparator() {
<span class="nc" id="L277">        return BaseNCodec.CHUNK_SEPARATOR.clone();</span>
    }

    /**
     * Checks if a byte value is whitespace or not.
     * Whitespace is taken to mean: space, tab, CR, LF
     * @param byteToCheck
     *            the byte to check
     * @return true if byte is whitespace, false otherwise
     */
    protected static boolean isWhiteSpace(final byte byteToCheck) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        switch (byteToCheck) {</span>
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
<span class="nc" id="L293">                return true;</span>
            default :
<span class="nc" id="L295">                return false;</span>
        }
    }

    /**
     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.
     * @param context the context to be used
     * @param minCapacity the minimum required capacity
     * @return the resized byte[] buffer
     * @throws OutOfMemoryError if the {@code minCapacity} is negative
     */
    private static byte[] resizeBuffer(final Context context, final int minCapacity) {
        // Overflow-conscious code treats the min and new capacity as unsigned.
<span class="nc" id="L308">        final int oldCapacity = context.buffer.length;</span>
<span class="nc" id="L309">        int newCapacity = oldCapacity * BaseNCodec.DEFAULT_BUFFER_RESIZE_FACTOR;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (BaseNCodec.compareUnsigned(newCapacity, minCapacity) &lt; 0) {</span>
<span class="nc" id="L311">            newCapacity = minCapacity;</span>
        }
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (BaseNCodec.compareUnsigned(newCapacity, BaseNCodec.MAX_BUFFER_SIZE) &gt; 0) {</span>
<span class="nc" id="L314">            newCapacity = BaseNCodec.createPositiveCapacity(minCapacity);</span>
        }
<span class="nc" id="L316">        final var b = new byte[newCapacity];</span>
<span class="nc" id="L317">        System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);</span>
<span class="nc" id="L318">        context.buffer = b;</span>
<span class="nc" id="L319">        return b;</span>
    }

    /**
     * Returns the amount of buffered data available for reading.
     *
     * @param context the context to be used
     * @return The amount of buffered data available for reading.
     */
    private int available(final Context context) {  // package protected for access from I/O streams
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        return context.buffer != null ? context.pos - context.readPos : 0;</span>
    }

    /**
     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.
     *
     * Intended for use in checking line-ending arrays
     *
     * @param arrayOctet
     *            byte array to test
     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise
     */
    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (arrayOctet == null) {</span>
<span class="nc" id="L343">            return false;</span>
        }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (final byte element : arrayOctet) {</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">            if (this.pad == element || this.isInAlphabet(element)) {</span>
<span class="nc" id="L347">                return true;</span>
            }
        }
<span class="nc" id="L350">        return false;</span>
    }

    /**
     * Decodes a byte[] containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A byte array containing Base-N character data
     * @return a byte array containing binary data
     */
    @Override
    public byte[] decode(final byte[] pArray) {
<span class="pc bpc" id="L362" title="2 of 4 branches missed.">        if (pArray == null || pArray.length == 0) {</span>
<span class="nc" id="L363">            return pArray;</span>
        }
<span class="fc" id="L365">        final var context = new Context();</span>
<span class="fc" id="L366">        this.decode(pArray, 0, pArray.length, context);</span>
<span class="fc" id="L367">        this.decode(pArray, 0, BaseNCodec.EOF, context); // Notify decoder of EOF.</span>
<span class="fc" id="L368">        final var result = new byte[context.pos];</span>
<span class="fc" id="L369">        this.readResults(result, 0, result.length, context);</span>
<span class="fc" id="L370">        return result;</span>
    }

    // package protected for access from I/O streams
    public abstract void decode(byte[] pArray, int i, int length, Context context);

    /**
     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.
     *
     * @param obj
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String
     *         supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */
    @Override
    public Object decode(final Object obj) throws DecoderException {
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (obj instanceof byte[]) {</span>
<span class="nc" id="L390">            return this.decode((byte[]) obj);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        } else if (obj instanceof String) {</span>
<span class="nc" id="L392">            return this.decode((String) obj);</span>
        } else {
<span class="nc" id="L394">            throw new DecoderException(&quot;Parameter supplied to Base-N decode is not a byte[] or a String&quot;);</span>
        }
    }

    /**
     * Decodes a String containing characters in the Base-N alphabet.
     *
     * @param pArray
     *            A String containing Base-N character data
     * @return a byte array containing binary data
     */
    public byte[] decode(final String pArray) {
<span class="fc" id="L406">        return this.decode(StringUtils.getBytesUtf8(pArray));</span>
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only the base N alphabetic character data
     */
    @Override
    public byte[] encode(final byte[] pArray) {
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">        if (pArray == null || pArray.length == 0) {</span>
<span class="nc" id="L419">            return pArray;</span>
        }
<span class="fc" id="L421">        return this.encode(pArray, 0, pArray.length);</span>
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing
     * characters in the alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @param offset
     *            initial offset of the subarray.
     * @param length
     *            length of the subarray.
     * @return A byte array containing only the base N alphabetic character data
     * @since 1.11
     */
    public byte[] encode(final byte[] pArray, final int offset, final int length) {
<span class="pc bpc" id="L438" title="2 of 4 branches missed.">        if (pArray == null || pArray.length == 0) {</span>
<span class="nc" id="L439">            return pArray;</span>
        }
<span class="fc" id="L441">        final var context = new Context();</span>
<span class="fc" id="L442">        this.encode(pArray, offset, length, context);</span>
<span class="fc" id="L443">        this.encode(pArray, offset, BaseNCodec.EOF, context); // Notify encoder of EOF.</span>
<span class="fc" id="L444">        final var buf = new byte[context.pos - context.readPos];</span>
<span class="fc" id="L445">        this.readResults(buf, 0, buf.length, context);</span>
<span class="fc" id="L446">        return buf;</span>
    }

    // package protected for access from I/O streams
    public abstract void encode(byte[] pArray, int i, int length, Context context);

    /**
     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of
     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param obj
     *            Object to encode
     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */
    @Override
    public Object encode(final Object obj) throws EncoderException {
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (!(obj instanceof byte[])) {</span>
<span class="nc" id="L465">            throw new EncoderException(&quot;Parameter supplied to Base-N encode is not a byte[]&quot;);</span>
        }
<span class="nc" id="L467">        return this.encode((byte[]) obj);</span>
    }

    /**
     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.
     * Uses UTF8 encoding.
     *
     * @param pArray a byte array containing binary data
     * @return String containing only character data in the appropriate alphabet.
     * @since 1.5
     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.
    */
    public String encodeAsString(final byte[] pArray){
<span class="nc" id="L480">        return StringUtils.newStringUtf8(this.encode(pArray));</span>
    }

    /**
     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.
     * Uses UTF8 encoding.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A String containing only Base-N character data
     */
    public String encodeToString(final byte[] pArray) {
<span class="fc" id="L492">        return StringUtils.newStringUtf8(this.encode(pArray));</span>
    }

    /**
     * Ensure that the buffer has room for {@code size} bytes
     *
     * @param size minimum spare space required
     * @param context the context to be used
     * @return the buffer
     */
    protected byte[] ensureBufferSize(final int size, final Context context) {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if (context.buffer == null) {</span>
<span class="fc" id="L504">            context.buffer = new byte[Math.max(size, this.getDefaultBufferSize())];</span>
<span class="fc" id="L505">            context.pos = 0;</span>
<span class="fc" id="L506">            context.readPos = 0;</span>
            // Overflow-conscious:
            // x + y &gt; z  ==  x + y - z &gt; 0
<span class="nc bnc" id="L509" title="All 2 branches missed.">        } else if (context.pos + size - context.buffer.length &gt; 0) {</span>
<span class="nc" id="L510">            return BaseNCodec.resizeBuffer(context, context.pos + size);</span>
        }
<span class="fc" id="L512">        return context.buffer;</span>
    }

    /**
     * Returns the decoding behavior policy.
     * 
     * &lt;p&gt;
     * The default is lenient. If the decoding policy is strict, then decoding will raise an
     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding. Decoding will compose
     * trailing bits into 8-bit bytes and discard the remainder.
     * &lt;/p&gt;
     *
     * @since 1.15
     */
    public CodecPolicy getCodecPolicy() {
<span class="nc" id="L527">        return this.decodingPolicy;</span>
    }

    /**
     * Get the default buffer size. Can be overridden.
     *
     * @return the default buffer size.
     */
    protected int getDefaultBufferSize() {
<span class="fc" id="L536">        return BaseNCodec.DEFAULT_BUFFER_SIZE;</span>
    }

    /**
     * Calculates the amount of space needed to encode the supplied array.
     *
     * @param pArray byte[] array which will later be encoded
     *
     * @return amount of space needed to encode the supplied array.
     * Returns a long since a max-len array will require &amp;gt; Integer.MAX_VALUE
     */
    public long getEncodedLength(final byte[] pArray) {
        // Calculate non-chunked size - rounded up to allow for padding
        // cast to long is needed to avoid possibility of overflow
<span class="nc" id="L550">        long len = (pArray.length + this.unencodedBlockSize-1)  / this.unencodedBlockSize * (long) this.encodedBlockSize;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (this.lineLength &gt; 0) { // We're using chunking</span>
            // Round up to nearest multiple
<span class="nc" id="L553">            len += (len + this.lineLength-1) / this.lineLength * this.chunkSeparatorLength;</span>
        }
<span class="nc" id="L555">        return len;</span>
    }

    /**
     * Returns true if this object has buffered data for reading.
     *
     * @param context the context to be used
     * @return true if there is data still available for reading.
     */
    public boolean hasData(final Context context) {  // package protected for access from I/O streams
<span class="nc bnc" id="L565" title="All 2 branches missed.">        return context.buffer != null;</span>
    }

    /**
     * Returns whether the {@code octet} is in the current alphabet.
     * Does not allow whitespace or pad.
     *
     * @param value The value to test
     *
     * @return {@code true} if the value is defined in the current alphabet, {@code false} otherwise.
     */
    protected abstract boolean isInAlphabet(byte value);

    /**
     * Tests a given byte array to see if it contains only valid characters within the alphabet.
     * The method optionally treats whitespace and pad as valid.
     *
     * @param arrayOctet byte array to test
     * @param allowWSPad if {@code true}, then whitespace and PAD are also allowed
     *
     * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     */
    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">        for (final byte octet : arrayOctet) {</span>
<span class="nc" id="L590">            if (</span>
<span class="nc bnc" id="L591" title="All 6 branches missed.">                !this.isInAlphabet(octet)</span>
                &amp;&amp; (!allowWSPad || (octet != this.pad)
<span class="nc bnc" id="L593" title="All 2 branches missed.">                &amp;&amp; !BaseNCodec.isWhiteSpace(octet))</span>
            ) {
<span class="nc" id="L595">                return false;</span>
            }
        }
<span class="nc" id="L598">        return true;</span>
    }

    /**
     * Tests a given String to see if it contains only valid characters within the alphabet.
     * The method treats whitespace and PAD as valid.
     *
     * @param basen String to test
     * @return {@code true} if all characters in the String are valid characters in the alphabet or if
     *         the String is empty; {@code false}, otherwise
     * @see #isInAlphabet(byte[], boolean)
     */
    public boolean isInAlphabet(final String basen) {
<span class="nc" id="L611">        return this.isInAlphabet(StringUtils.getBytesUtf8(basen), true);</span>
    }

    /**
     * Returns true if decoding behavior is strict. Decoding will raise an {@link IllegalArgumentException} if trailing
     * bits are not part of a valid encoding.
     *
     * &lt;p&gt;
     * The default is false for lenient decoding. Decoding will compose trailing bits into 8-bit bytes and discard the
     * remainder.
     * &lt;/p&gt;
     *
     * @return true if using strict decoding
     * @since 1.15
     */
    public boolean isStrictDecoding() {
<span class="nc bnc" id="L627" title="All 2 branches missed.">        return this.decodingPolicy == CodecPolicy.STRICT;</span>
    }

    /**
     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail
     * bytes. Returns how many bytes were actually extracted.
     * &lt;p&gt;
     * Package protected for access from I/O streams.
     *
     * @param b       byte[] array to extract the buffered data into.
     * @param bPos    position in byte[] array to start extraction at.
     * @param bAvail  amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
     * @param context the context to be used
     */
    private void readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (context.buffer != null) {</span>
<span class="fc" id="L643">            final int len = Math.min(this.available(context), bAvail);</span>
<span class="fc" id="L644">            System.arraycopy(context.buffer, context.readPos, b, bPos, len);</span>
<span class="fc" id="L645">            context.readPos += len;</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            if (context.readPos &gt;= context.pos) {</span>
<span class="fc" id="L647">                context.buffer = null; // so hasData() will return false, and this method can return -1</span>
            }
        }
<span class="fc" id="L650">    }</span>

    /**
     * Holds thread context so classes can be thread-safe.
     *
     * This class is not itself thread-safe; each thread must allocate its own copy.
     *
     * @since 1.7
     */
<span class="fc" id="L659">    protected static class Context {</span>

        /**
         * Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.
         */
        protected int ibitWorkArea;

        /**
         * Placeholder for the bytes we're dealing with for our based logic.
         * Bitwise operations store and extract the encoding or decoding from this variable.
         */
        protected long lbitWorkArea;

        /**
         * Buffer for streaming.
         */
        protected byte[] buffer;

        /**
         * Position where next character should be written in the buffer.
         */
        protected int pos;

        /**
         * Position where next character should be read from the buffer.
         */
        protected int readPos;

        /**
         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
         * and must be thrown away.
         */
        protected boolean eof;

        /**
         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use
         * it to make sure each encoded line never goes beyond lineLength (if lineLength &amp;gt; 0).
         */
        protected int currentLinePos;

        /**
         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This
         * variable helps track that.
         */
        protected int modulus;

        /**
         * Returns a String useful for debugging (especially within a debugger.)
         *
         * @return a String useful for debugging.
         */
        @SuppressWarnings(&quot;boxing&quot;) // OK to ignore boxing here
        @Override
        public String toString() {
<span class="nc" id="L714">            return String.format(</span>
                &quot;%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]&quot;,
<span class="nc" id="L716">                this.getClass().getSimpleName(),</span>
<span class="nc" id="L717">                Arrays.toString(this.buffer),</span>
<span class="nc" id="L718">                this.currentLinePos,</span>
<span class="nc" id="L719">                this.eof,</span>
<span class="nc" id="L720">                this.ibitWorkArea,</span>
<span class="nc" id="L721">                this.lbitWorkArea,</span>
<span class="nc" id="L722">                this.modulus,</span>
<span class="nc" id="L723">                this.pos,</span>
<span class="nc" id="L724">                this.readPos</span>
            );
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>