<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DigestMD4.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.util.bruter</a> &gt; <span class="el_source">DigestMD4.java</span></div><h1>DigestMD4.java</h1><pre class="source lang-java linenums">package com.jsql.util.bruter;

// This file is currently unlocked (change this line if you lock the file)
//
// $Log: MD4.java,v $
// Revision 1.2  1998/01/05 03:41:19  iang
// Added references only.
//
// Revision 1.1.1.1  1997/11/03 22:36:56  hopwood
// + Imported to CVS (tagged as 'start').
//
// Revision 0.1.0.0  1997/07/14  R. Naffah
// + original version
//
// $Endlog$
/*
 * Copyright (c) 1997 Systemics Ltd
 * on behalf of the Cryptix Development Team.  All rights reserved.
 */

import java.security.MessageDigest;

/**
 * Implements the MD4 message digest algorithm in Java.
 * &lt;p&gt;
 * &lt;b&gt;References:&lt;/b&gt;
 * &lt;ol&gt;
 *   &lt;li&gt; Ronald L. Rivest,
 *        &quot;&lt;a href=&quot;http://www.roxen.com/rfc/rfc1320.html&quot;&gt;
 *        The MD4 Message-Digest Algorithm&lt;/a&gt;&quot;,
 *        IETF RFC-1320 (informational).
 * &lt;/ol&gt;
 *
 * &lt;p&gt;&lt;b&gt;$Revision: 1.2 $&lt;/b&gt;
 * @author  Raif S. Naffah
 */
public class DigestMD4 extends MessageDigest implements Cloneable {
    
    // MD4 specific object variables
    //...........................................................................

    /**
     * The size in bytes of the input block to the tranformation algorithm.
     */
    private static final int BLOCK_LENGTH = 64; //512 / 8

    /**
     * 4 32-bit words (interim result)
     */
<span class="fc" id="L50">    private int[] context = new int[4];</span>

    /**
     * Number of bytes processed so far mod. 2 power of 64.
     */
    private long count;

    /**
     * 512 bits input buffer = 16 x 32-bit words holds until reaches 512 bits.
     */
<span class="fc" id="L60">    private byte[] buffer = new byte[DigestMD4.BLOCK_LENGTH];</span>

    /**
     * 512 bits work buffer = 16 x 32-bit words
     */
<span class="fc" id="L65">    private final int[] X = new int[16];</span>


    // Constructors
    //...........................................................................

    public DigestMD4() {
<span class="fc" id="L72">        super(&quot;MD4&quot;);</span>
<span class="fc" id="L73">        this.engineReset();</span>
<span class="fc" id="L74">    }</span>

    /**
     *    This constructor is here to implement cloneability of this class.
     */
    private DigestMD4(DigestMD4 md) {
<span class="nc" id="L80">        this();</span>
<span class="nc" id="L81">        this.context = md.context.clone();</span>
<span class="nc" id="L82">        this.buffer = md.buffer.clone();</span>
<span class="nc" id="L83">        this.count = md.count;</span>
<span class="nc" id="L84">    }</span>


    // Cloneable method implementation
    //...........................................................................

    /**
     * Returns a copy of this MD object.
     */
    @Override
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L95">        super.clone();</span>
<span class="nc" id="L96">        return new DigestMD4(this);</span>
    }


    // JCE methods
    //...........................................................................

    /**
     * Resets this object disregarding any temporary data present at the
     * time of the invocation of this call.
     */
    @Override
    public void engineReset() {
        // initial values of MD4 i.e. A, B, C, D
        // as per rfc-1320; they are low-order byte first
<span class="fc" id="L111">        this.context[0] = 0x67452301;</span>
<span class="fc" id="L112">        this.context[1] = 0xEFCDAB89;</span>
<span class="fc" id="L113">        this.context[2] = 0x98BADCFE;</span>
<span class="fc" id="L114">        this.context[3] = 0x10325476;</span>
<span class="fc" id="L115">        this.count = 0L;</span>
        
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (int i = 0; i &lt; DigestMD4.BLOCK_LENGTH; i++) {</span>
<span class="fc" id="L118">            this.buffer[i] = 0;</span>
        }
<span class="fc" id="L120">    }</span>

    /**
     * Continues an MD4 message digest using the input byte.
     */
    @Override
    public void engineUpdate(byte b) {
        // compute number of bytes still unhashed; i.e. present in buffer
<span class="nc" id="L128">        int i = (int)(this.count % DigestMD4.BLOCK_LENGTH);</span>
<span class="nc" id="L129">        this.count++;                                        // update number of bytes</span>
<span class="nc" id="L130">        this.buffer[i] = b;</span>
        
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (i == DigestMD4.BLOCK_LENGTH - 1) {</span>
<span class="nc" id="L133">            this.transform(this.buffer, 0);</span>
        }
<span class="nc" id="L135">    }</span>

    /**
     * MD4 block update operation.
     * &lt;p&gt;
     * Continues an MD4 message digest operation, by filling the buffer,
     * transform(ing) data in 512-bit message block(s), updating the variables
     * context and count, and leaving (buffering) the remaining bytes in buffer
     * for the next update or finish.
     *
     * @param    input    input block
     * @param    offset    start of meaningful bytes in input
     * @param    len        count of bytes in input block to consider
     */
    @Override
    public void engineUpdate(byte[] input, int offset, int len) {
        // make sure we don't exceed input's allocated size/length
<span class="pc bpc" id="L152" title="3 of 6 branches missed.">        if (offset &lt; 0 || len &lt; 0 || (long) offset + len &gt; input.length) {</span>
<span class="nc" id="L153">            throw new ArrayIndexOutOfBoundsException();</span>
        }
        
        // compute number of bytes still unhashed; i.e. present in buffer
<span class="fc" id="L157">        int bufferNdx = (int)(this.count % DigestMD4.BLOCK_LENGTH);</span>
<span class="fc" id="L158">        this.count += len;                                        // update number of bytes</span>
<span class="fc" id="L159">        int partLen = DigestMD4.BLOCK_LENGTH - bufferNdx;</span>
<span class="fc" id="L160">        int i = 0;</span>
        
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (len &gt;= partLen) {</span>
            
<span class="fc" id="L164">            System.arraycopy(input, offset, this.buffer, bufferNdx, partLen);</span>

<span class="fc" id="L166">            this.transform(this.buffer, 0);</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            for (i = partLen; i + DigestMD4.BLOCK_LENGTH - 1 &lt; len; i+= DigestMD4.BLOCK_LENGTH) {</span>
<span class="nc" id="L169">                this.transform(input, offset + i);</span>
            }
            
<span class="fc" id="L172">            bufferNdx = 0;</span>
        }
        
        // buffer remaining input
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (i &lt; len) {</span>
<span class="fc" id="L177">            System.arraycopy(input, offset + i, this.buffer, bufferNdx, len - i);</span>
        }
<span class="fc" id="L179">    }</span>

    /**
     * Completes the hash computation by performing final operations such
     * as padding. At the return of this engineDigest, the MD engine is
     * reset.
     *
     * @return the array of bytes for the resulting hash value.
     */
    @Override
    public byte[] engineDigest() {
        // pad output to 56 mod 64; as RFC1320 puts it: congruent to 448 mod 512
<span class="fc" id="L191">        int bufferNdx = (int)(this.count % DigestMD4.BLOCK_LENGTH);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        int padLen = bufferNdx &lt; 56 ? 56 - bufferNdx : 120 - bufferNdx;</span>

        // padding is alwas binary 1 followed by binary 0s
<span class="fc" id="L195">        byte[] tail = new byte[padLen + 8];</span>
<span class="fc" id="L196">        tail[0] = (byte) 0x80;</span>

        // append length before final transform:
        // save number of bits, casting the long to an array of 8 bytes
        // save low-order byte first.
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc" id="L202">            tail[padLen + i] = (byte)((this.count * 8) &gt;&gt;&gt; (8 * i));</span>
        }
        
<span class="fc" id="L205">        this.engineUpdate(tail, 0, tail.length);</span>

<span class="fc" id="L207">        byte[] result = new byte[16];</span>
        
        // cast this MD4's context (array of 4 ints) into an array of 16 bytes.
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            for (int j = 0; j &lt; 4; j++) {</span>
<span class="fc" id="L212">                result[i * 4 + j] = (byte)(this.context[i] &gt;&gt;&gt; (8 * j));</span>
            }
        }
    
        // reset the engine
<span class="fc" id="L217">        this.engineReset();</span>
        
<span class="fc" id="L219">        return result;</span>
    }


    // own methods
    //...........................................................................

    /**
     *    MD4 basic transformation.
     *    &lt;p&gt;
     *    Transforms context based on 512 bits from input block starting
     *    from the offset'th byte.
     *
     *    @param    block    input sub-array.
     *    @param    offset    starting position of sub-array.
     */
    private void transform(byte[] block, int offset) {
        // encodes 64 bytes from input block into an array of 16 32-bit
        // entities. Use A as a temp var.
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (int i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L239">            this.X[i] =</span>
                (block[offset++] &amp; 0xFF)
                | (block[offset++] &amp; 0xFF) &lt;&lt;  8
                | (block[offset++] &amp; 0xFF) &lt;&lt; 16
                | (block[offset++] &amp; 0xFF) &lt;&lt; 24;
        }

<span class="fc" id="L246">        int A = this.context[0];</span>
<span class="fc" id="L247">        int B = this.context[1];</span>
<span class="fc" id="L248">        int C = this.context[2];</span>
<span class="fc" id="L249">        int D = this.context[3];</span>

<span class="fc" id="L251">        A = this.FF(A, B, C, D, this.X[ 0],  3);</span>
<span class="fc" id="L252">        D = this.FF(D, A, B, C, this.X[ 1],  7);</span>
<span class="fc" id="L253">        C = this.FF(C, D, A, B, this.X[ 2], 11);</span>
<span class="fc" id="L254">        B = this.FF(B, C, D, A, this.X[ 3], 19);</span>
<span class="fc" id="L255">        A = this.FF(A, B, C, D, this.X[ 4],  3);</span>
<span class="fc" id="L256">        D = this.FF(D, A, B, C, this.X[ 5],  7);</span>
<span class="fc" id="L257">        C = this.FF(C, D, A, B, this.X[ 6], 11);</span>
<span class="fc" id="L258">        B = this.FF(B, C, D, A, this.X[ 7], 19);</span>
<span class="fc" id="L259">        A = this.FF(A, B, C, D, this.X[ 8],  3);</span>
<span class="fc" id="L260">        D = this.FF(D, A, B, C, this.X[ 9],  7);</span>
<span class="fc" id="L261">        C = this.FF(C, D, A, B, this.X[10], 11);</span>
<span class="fc" id="L262">        B = this.FF(B, C, D, A, this.X[11], 19);</span>
<span class="fc" id="L263">        A = this.FF(A, B, C, D, this.X[12],  3);</span>
<span class="fc" id="L264">        D = this.FF(D, A, B, C, this.X[13],  7);</span>
<span class="fc" id="L265">        C = this.FF(C, D, A, B, this.X[14], 11);</span>
<span class="fc" id="L266">        B = this.FF(B, C, D, A, this.X[15], 19);</span>

<span class="fc" id="L268">        A = this.GG(A, B, C, D, this.X[ 0],  3);</span>
<span class="fc" id="L269">        D = this.GG(D, A, B, C, this.X[ 4],  5);</span>
<span class="fc" id="L270">        C = this.GG(C, D, A, B, this.X[ 8],  9);</span>
<span class="fc" id="L271">        B = this.GG(B, C, D, A, this.X[12], 13);</span>
<span class="fc" id="L272">        A = this.GG(A, B, C, D, this.X[ 1],  3);</span>
<span class="fc" id="L273">        D = this.GG(D, A, B, C, this.X[ 5],  5);</span>
<span class="fc" id="L274">        C = this.GG(C, D, A, B, this.X[ 9],  9);</span>
<span class="fc" id="L275">        B = this.GG(B, C, D, A, this.X[13], 13);</span>
<span class="fc" id="L276">        A = this.GG(A, B, C, D, this.X[ 2],  3);</span>
<span class="fc" id="L277">        D = this.GG(D, A, B, C, this.X[ 6],  5);</span>
<span class="fc" id="L278">        C = this.GG(C, D, A, B, this.X[10],  9);</span>
<span class="fc" id="L279">        B = this.GG(B, C, D, A, this.X[14], 13);</span>
<span class="fc" id="L280">        A = this.GG(A, B, C, D, this.X[ 3],  3);</span>
<span class="fc" id="L281">        D = this.GG(D, A, B, C, this.X[ 7],  5);</span>
<span class="fc" id="L282">        C = this.GG(C, D, A, B, this.X[11],  9);</span>
<span class="fc" id="L283">        B = this.GG(B, C, D, A, this.X[15], 13);</span>

<span class="fc" id="L285">        A = this.HH(A, B, C, D, this.X[ 0],  3);</span>
<span class="fc" id="L286">        D = this.HH(D, A, B, C, this.X[ 8],  9);</span>
<span class="fc" id="L287">        C = this.HH(C, D, A, B, this.X[ 4], 11);</span>
<span class="fc" id="L288">        B = this.HH(B, C, D, A, this.X[12], 15);</span>
<span class="fc" id="L289">        A = this.HH(A, B, C, D, this.X[ 2],  3);</span>
<span class="fc" id="L290">        D = this.HH(D, A, B, C, this.X[10],  9);</span>
<span class="fc" id="L291">        C = this.HH(C, D, A, B, this.X[ 6], 11);</span>
<span class="fc" id="L292">        B = this.HH(B, C, D, A, this.X[14], 15);</span>
<span class="fc" id="L293">        A = this.HH(A, B, C, D, this.X[ 1],  3);</span>
<span class="fc" id="L294">        D = this.HH(D, A, B, C, this.X[ 9],  9);</span>
<span class="fc" id="L295">        C = this.HH(C, D, A, B, this.X[ 5], 11);</span>
<span class="fc" id="L296">        B = this.HH(B, C, D, A, this.X[13], 15);</span>
<span class="fc" id="L297">        A = this.HH(A, B, C, D, this.X[ 3],  3);</span>
<span class="fc" id="L298">        D = this.HH(D, A, B, C, this.X[11],  9);</span>
<span class="fc" id="L299">        C = this.HH(C, D, A, B, this.X[ 7], 11);</span>
<span class="fc" id="L300">        B = this.HH(B, C, D, A, this.X[15], 15);</span>

<span class="fc" id="L302">        this.context[0] += A;</span>
<span class="fc" id="L303">        this.context[1] += B;</span>
<span class="fc" id="L304">        this.context[2] += C;</span>
<span class="fc" id="L305">        this.context[3] += D;</span>
<span class="fc" id="L306">    }</span>

    // The basic MD4 atomic functions.

    private int FF(int a, int b, int c, int d, int x, int s) {
<span class="fc" id="L311">        int t = a + ((b &amp; c) | (~b &amp; d)) + x;</span>
<span class="fc" id="L312">        return t &lt;&lt; s | t &gt;&gt;&gt; (32 - s);</span>
    }
    
    private int GG(int a, int b, int c, int d, int x, int s) {
<span class="fc" id="L316">        int t = a + ((b &amp; (c | d)) | (c &amp; d)) + x + 0x5A827999;</span>
<span class="fc" id="L317">        return t &lt;&lt; s | t &gt;&gt;&gt; (32 - s);</span>
    }
    
    private int HH(int a, int b, int c, int d, int x, int s) {
<span class="fc" id="L321">        int t = a + (b ^ c ^ d) + x + 0x6ED9EBA1;</span>
<span class="fc" id="L322">        return t &lt;&lt; s | t &gt;&gt;&gt; (32 - s);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>