<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SuspendableGetRows.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model.suspendable</a> &gt; <span class="el_source">SuspendableGetRows.java</span></div><h1>SuspendableGetRows.java</h1><pre class="source lang-java linenums">package com.jsql.model.suspendable;

import com.jsql.model.InjectionModel;
import com.jsql.model.bean.database.AbstractElementDatabase;
import com.jsql.model.bean.database.Table;
import com.jsql.model.bean.util.Interaction;
import com.jsql.model.bean.util.Request;
import com.jsql.model.exception.AbstractSlidingException;
import com.jsql.model.exception.InjectionFailureException;
import com.jsql.model.exception.LoopDetectedSlidingException;
import com.jsql.model.exception.StoppedByUserSlidingException;
import com.jsql.model.injection.strategy.AbstractStrategy;
import com.jsql.util.LogLevelUtil;
import com.jsql.util.StringUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static com.jsql.model.accessible.DataAccess.*;
import static com.jsql.model.injection.vendor.model.VendorYaml.LIMIT;

/**
 * Get data as chunks by performance query from SQL request.
 * 
 * &lt;pre&gt;
 * Single row format: \4[0-9A-F]*\5[0-9A-F]*c?\4
 * Row separator: \6
 * Tape example: \4xxRow#Xxx\5x\4\6\4xxRow#X+1xx\5x\4\6...\4\1\3\3\7&lt;/pre&gt;
 * 
 * MID and LIMIT move two sliding windows in a 2D array tape in that order.
 * MID skips characters when collected, then LIMIT skips lines when collected.
 * The process can be interrupted by the user (stop/pause).
 */
public class SuspendableGetRows extends AbstractSuspendable {

    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L48">    private static final Logger LOGGER = LogManager.getRootLogger();</span>

    public SuspendableGetRows(InjectionModel injectionModel) {
<span class="fc" id="L51">        super(injectionModel);</span>
<span class="fc" id="L52">    }</span>

    @Override
    public String run(Object... args) throws AbstractSlidingException {
        // TODO Map class
<span class="fc" id="L57">        String initialSqlQuery = (String) args[0];</span>
<span class="fc" id="L58">        String[] sourcePage = (String[]) args[1];</span>
<span class="fc" id="L59">        boolean isMultipleRows = (Boolean) args[2];</span>
<span class="fc" id="L60">        int countRowsToFind = (Integer) args[3];</span>
<span class="fc" id="L61">        AbstractElementDatabase elementDatabase = (AbstractElementDatabase) args[4];</span>
<span class="fc" id="L62">        String metadataInjectionProcess = (String) args[5];</span>
        
<span class="fc" id="L64">        this.injectionModel.getMediatorUtils().getThreadUtil().put(elementDatabase, this);</span>

<span class="fc" id="L66">        AbstractStrategy strategy = this.injectionModel.getMediatorStrategy().getStrategy();</span>
        
        // Fix #14417
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        if (strategy == null) {</span>
<span class="nc" id="L70">            return StringUtils.EMPTY;</span>
        }
        
        // Stop injection if all rows are found, skip rows and characters collected
<span class="fc" id="L74">        var slidingWindowAllRows = new StringBuilder();</span>
<span class="fc" id="L75">        var slidingWindowCurrentRow = new StringBuilder();</span>
        
<span class="fc" id="L77">        String previousChunk = StringUtils.EMPTY;</span>
<span class="fc" id="L78">        var countAllRows = 0;</span>
<span class="fc" id="L79">        var charPositionInCurrentRow = 1;</span>
<span class="fc" id="L80">        var countInfiniteLoop = 0;</span>
        
<span class="fc" id="L82">        String queryGetRows = this.getQuery(initialSqlQuery, countAllRows);</span>
        
        while (true) {
<span class="fc" id="L85">            this.checkSuspend(strategy, slidingWindowAllRows, slidingWindowCurrentRow);</span>
            
<span class="fc" id="L87">            sourcePage[0] = strategy.inject(queryGetRows, Integer.toString(charPositionInCurrentRow), this, metadataInjectionProcess);</span>
            // Parse all the data we have retrieved
<span class="fc" id="L89">            Matcher regexLeadFound = this.parseLeadFound(sourcePage[0], strategy.getPerformanceLength());</span>
<span class="fc" id="L90">            Matcher regexTrailOnlyFound = this.parseTrailOnlyFound(sourcePage[0]);</span>
            
<span class="fc" id="L92">            if (</span>
<span class="fc bfc" id="L93" title="All 6 branches covered.">                (!regexLeadFound.find() || regexTrailOnlyFound.find())</span>
                &amp;&amp; isMultipleRows
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                &amp;&amp; StringUtils.isNotEmpty(slidingWindowAllRows.toString())</span>
            ) {
<span class="fc" id="L97">                this.sendProgress(countRowsToFind, countRowsToFind, elementDatabase);</span>
<span class="fc" id="L98">                break;</span>
            }

            // Add the result to the data already found.
            // Fix #40947: OutOfMemoryError on append()
            // Fix #95382: IllegalArgumentException on URLDecoder.decode()
            try {
<span class="fc" id="L105">                String currentChunk = regexLeadFound.group(1);</span>
<span class="fc" id="L106">                currentChunk = this.decodeUnicode(currentChunk, initialSqlQuery);</span>
<span class="fc" id="L107">                currentChunk = this.decodeUrl(currentChunk);</span>

<span class="fc" id="L109">                countInfiniteLoop = this.checkInfinite(countInfiniteLoop, previousChunk, currentChunk, slidingWindowCurrentRow, slidingWindowAllRows);</span>
                
<span class="fc" id="L111">                previousChunk = currentChunk;</span>
<span class="fc" id="L112">                slidingWindowCurrentRow.append(currentChunk);</span>
<span class="fc" id="L113">                this.sendChunk(currentChunk);</span>
<span class="fc" id="L114">            } catch (IllegalArgumentException | IllegalStateException | OutOfMemoryError e) {</span>
<span class="nc" id="L115">                this.endInjection(elementDatabase, e);</span>
<span class="fc" id="L116">            }</span>

            // Check how many rows we have collected from the beginning of that chunk
<span class="fc" id="L119">            int countChunkRows = this.getCountRows(slidingWindowCurrentRow);</span>
<span class="fc" id="L120">            this.sendProgress(countRowsToFind, countAllRows + countChunkRows, elementDatabase);</span>

            // End of rows detected: \1\3\3\7
            // =&gt; \4xxxxxxxx\500\4\6\4...\4\1\3\3\7
<span class="fc bfc" id="L124" title="All 2 branches covered.">            if (</span>
                countChunkRows &gt; 0
<span class="fc bfc" id="L126" title="All 2 branches covered.">                || slidingWindowCurrentRow.toString().matches(&quot;(?s).*&quot;+ TRAIL_RGX +&quot;.*&quot;)</span>
            ) {
<span class="fc" id="L128">                this.scrapeTrailJunk(slidingWindowCurrentRow);</span>
<span class="fc" id="L129">                slidingWindowAllRows.append(slidingWindowCurrentRow);</span>
                
<span class="fc bfc" id="L131" title="All 2 branches covered.">                if (isMultipleRows) {</span>
<span class="fc" id="L132">                    this.scrap(slidingWindowAllRows);</span>
<span class="fc" id="L133">                    this.scrap(slidingWindowCurrentRow);</span>
<span class="fc" id="L134">                    this.appendRowFixed(slidingWindowAllRows, slidingWindowCurrentRow);</span>

<span class="fc" id="L136">                    countAllRows = this.getCountRows(slidingWindowAllRows);</span>
<span class="fc" id="L137">                    this.sendProgress(countRowsToFind, countAllRows, elementDatabase);</span>

                    // Ending condition: every expected rows have been retrieved.
<span class="fc bfc" id="L140" title="All 2 branches covered.">                    if (countAllRows == countRowsToFind) {</span>
<span class="fc" id="L141">                        break;</span>
                    }
                    // Add the LIMIT statement to the next SQL query and reset variables.
                    // Put the character cursor to the beginning of the line, and reset the result of the current query
<span class="fc" id="L145">                    queryGetRows = this.getQuery(initialSqlQuery, countAllRows);</span>
<span class="fc" id="L146">                    slidingWindowCurrentRow.setLength(0);</span>
                } else {
<span class="fc" id="L148">                    this.sendProgress(countRowsToFind, countRowsToFind, elementDatabase);</span>
<span class="fc" id="L149">                    break;</span>
                }
            }
<span class="fc" id="L152">            charPositionInCurrentRow = slidingWindowCurrentRow.length() + 1;</span>
<span class="fc" id="L153">        }</span>
<span class="fc" id="L154">        this.injectionModel.getMediatorUtils().getThreadUtil().remove(elementDatabase);</span>
<span class="fc" id="L155">        return slidingWindowAllRows.toString();</span>
    }

    private String decodeUrl(String currentChunk) {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (!this.injectionModel.getMediatorUtils().getPreferencesUtil().isUrlDecodeDisabled()) {</span>
            try {
<span class="fc" id="L161">                return URLDecoder.decode(currentChunk, StandardCharsets.UTF_8);  // Transform %00 entities to text</span>
<span class="nc" id="L162">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L163">                LOGGER.log(LogLevelUtil.CONSOLE_JAVA, &quot;Decoding fails on UT8, keeping raw result&quot;);</span>
            }
        }
<span class="nc" id="L166">        return currentChunk;</span>
    }

    private String decodeUnicode(String currentChunk, String initialSqlQuery) {
<span class="fc" id="L170">        if (</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            !this.injectionModel.getMediatorUtils().getPreferencesUtil().isUnicodeDecodeDisabled()</span>
<span class="fc bfc" id="L172" title="All 4 branches covered.">            &amp;&amp; !&quot;select@@plugin_dir&quot;.equals(initialSqlQuery)  // can give C:\path\</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            &amp;&amp; initialSqlQuery != null &amp;&amp; !initialSqlQuery.matches(&quot;(?si).*select.*sys_eval\\('.*'\\).*&quot;)</span>
        ) {
<span class="fc" id="L175">            return StringEscapeUtils.unescapeJava(  // transform \u0000 entities to text</span>
                currentChunk
<span class="fc" id="L177">                .replaceAll(&quot;\\\\u.{0,3}$&quot;, StringUtils.EMPTY)  // remove incorrect entities</span>
<span class="fc" id="L178">                .replaceAll(&quot;\\\\(\\d{4})&quot;, &quot;\\\\u$1&quot;)  // transform PDO Error 10.11.3-MariaDB-1 \0000 entities</span>
            );
        }
<span class="fc" id="L181">        return currentChunk;</span>
    }

    private String getQuery(String initialSqlQuery, int countAllRows) {
<span class="fc" id="L185">        return initialSqlQuery.replace(LIMIT, this.injectionModel.getMediatorVendor().getVendor().instance().sqlLimit(countAllRows));</span>
    }

    private void appendRowFixed(StringBuilder slidingWindowAllRows, StringBuilder slidingWindowCurrentRow) {
        // Check either if there is more than 1 row and if there is less than 1 complete row
<span class="fc" id="L190">        var regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L191">            String.format(</span>
                &quot;%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]%s%s%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;,
                MODE,
                ENCLOSE_VALUE_RGX,
                SEPARATOR_CELL_RGX,
                ENCLOSE_VALUE_RGX
            )
        )
<span class="fc" id="L199">        .matcher(slidingWindowCurrentRow);</span>
        
<span class="fc" id="L201">        var regexRowIncomplete = Pattern.compile(</span>
            MODE
            + ENCLOSE_VALUE_RGX
            + &quot;[^\\x01-\\x03\\x05-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;
        )
<span class="fc" id="L206">        .matcher(slidingWindowCurrentRow);</span>

        // If there is more than 1 row, delete the last incomplete one in order to restart properly from it at the next loop,
        // else if there is 1 row but incomplete, mark it as cut with the letter c
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (regexAtLeastOneRow.find()) {</span>
<span class="fc" id="L211">            var allLine = slidingWindowAllRows.toString();</span>
<span class="fc" id="L212">            slidingWindowAllRows.setLength(0);</span>
<span class="fc" id="L213">            slidingWindowAllRows.append(</span>
<span class="fc" id="L214">                Pattern.compile(</span>
                    MODE
                    + ENCLOSE_VALUE_RGX
                    + &quot;[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;
                )
<span class="fc" id="L219">                .matcher(allLine)</span>
<span class="fc" id="L220">                .replaceAll(StringUtils.EMPTY)</span>
            );
<span class="fc" id="L222">            LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Chunk unreliable, reloading row part...&quot;);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        } else if (regexRowIncomplete.find()) {</span>
<span class="nc" id="L224">            slidingWindowAllRows.append(StringUtil.hexstr(&quot;05&quot;)).append(&quot;1&quot;).append(StringUtil.hexstr(&quot;0804&quot;));</span>
<span class="nc" id="L225">            LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Chunk unreliable, keeping row parts only&quot;);</span>
        }
<span class="fc" id="L227">    }</span>

    private void scrapeTrailJunk(StringBuilder slidingWindowCurrentRow) {
        // Remove everything after chunk
        // =&gt; \4xxxxxxxx\500\4\6\4...\4 =&gt; \1\3\3\7junk
<span class="fc" id="L232">        var currentRow = slidingWindowCurrentRow.toString();</span>
<span class="fc" id="L233">        slidingWindowCurrentRow.setLength(0);</span>
<span class="fc" id="L234">        slidingWindowCurrentRow.append(</span>
<span class="fc" id="L235">            Pattern.compile(MODE + TRAIL_RGX +&quot;.*&quot;)</span>
<span class="fc" id="L236">            .matcher(currentRow)</span>
<span class="fc" id="L237">            .replaceAll(StringUtils.EMPTY)</span>
        );
<span class="fc" id="L239">    }</span>

    private int getCountRows(StringBuilder slidingWindowCurrentRow) {
<span class="fc" id="L242">        var regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L243">            String.format(</span>
                &quot;%s(%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?\\x08?%s)&quot;,
                MODE,
                ENCLOSE_VALUE_RGX,
                SEPARATOR_QTE_RGX,
                ENCLOSE_VALUE_RGX
            )
        )
<span class="fc" id="L251">        .matcher(slidingWindowCurrentRow);</span>
<span class="fc" id="L252">        var nbCompleteLine = 0;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        while (regexAtLeastOneRow.find()) {</span>
<span class="fc" id="L254">            nbCompleteLine++;</span>
        }
<span class="fc" id="L256">        return nbCompleteLine;</span>
    }

    private void endInjection(AbstractElementDatabase searchName, Throwable e) throws InjectionFailureException {
        // Premature end of results
        // if it's not the root (empty tree)
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (searchName != null) {</span>
<span class="fc" id="L263">            var request = new Request();</span>
<span class="fc" id="L264">            request.setMessage(Interaction.END_PROGRESS);</span>
<span class="fc" id="L265">            request.setParameters(searchName);</span>
<span class="fc" id="L266">            this.injectionModel.sendToViews(request);</span>
        }
<span class="fc" id="L268">        var messageError = new StringBuilder(&quot;Fetching fails: no data to parse&quot;);</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (searchName != null) {</span>
<span class="fc" id="L270">            messageError.append(&quot; for &quot;).append(StringUtil.detectUtf8(searchName.toString()));</span>
        }
<span class="pc bpc" id="L272" title="3 of 4 branches missed.">        if (searchName instanceof Table &amp;&amp; searchName.getChildCount() &gt; 0) {</span>
<span class="nc" id="L273">            messageError.append(&quot;, check Network tab for logs&quot;);</span>
        }
<span class="fc" id="L275">        throw new InjectionFailureException(messageError.toString(), e);</span>
    }

    private void sendChunk(String currentChunk) {
<span class="fc" id="L279">        var request = new Request();</span>
<span class="fc" id="L280">        request.setMessage(Interaction.MESSAGE_CHUNK);</span>
<span class="fc" id="L281">        request.setParameters(</span>
<span class="fc" id="L282">            Pattern.compile(MODE + TRAIL_RGX +&quot;.*&quot;)</span>
<span class="fc" id="L283">            .matcher(currentChunk)</span>
<span class="fc" id="L284">            .replaceAll(StringUtils.EMPTY)</span>
<span class="fc" id="L285">            .replace(&quot;\\n&quot;, &quot;\\\\\\n&quot;)</span>
<span class="fc" id="L286">            .replace(&quot;\\r&quot;, &quot;\\\\\\r&quot;)</span>
<span class="fc" id="L287">            .replace(&quot;\\t&quot;, &quot;\\\\\\t&quot;)</span>
        );
<span class="fc" id="L289">        this.injectionModel.sendToViews(request);</span>
<span class="fc" id="L290">    }</span>

    // TODO pb for same char string like aaaaaaaaaaaaa...aaaaaaaaaaaaa
    // detected as infinite
    private int checkInfinite(
        int loop,
        String previousChunk,
        String currentChunk,
        StringBuilder slidingWindowCurrentRow,
        StringBuilder slidingWindowAllRows
    ) throws LoopDetectedSlidingException {
<span class="fc" id="L301">        int infiniteLoop = loop;</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (previousChunk.equals(currentChunk)) {</span>
<span class="nc" id="L303">            infiniteLoop++;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (infiniteLoop &gt;= 20) {</span>
<span class="nc" id="L305">                this.stop();</span>
<span class="nc" id="L306">                throw new LoopDetectedSlidingException(</span>
<span class="nc" id="L307">                    slidingWindowAllRows.toString(),</span>
<span class="nc" id="L308">                    slidingWindowCurrentRow.toString()</span>
                );
            }
        }
<span class="fc" id="L312">        return infiniteLoop;</span>
    }

    private Matcher parseTrailOnlyFound(String sourcePage) {
<span class="fc" id="L316">        String sourcePageUnicodeDecoded = this.decodeUnicode(sourcePage, null);</span>
        // TODO: prevent to find the last line directly: MODE + LEAD + .* + TRAIL_RGX
        // It creates extra query which can be endless if not nullified
<span class="fc" id="L319">        return Pattern.compile(</span>
<span class="fc" id="L320">            String.format(&quot;(?s)%s(?i)%s&quot;, LEAD, TRAIL_RGX)</span>
        )
<span class="fc" id="L322">        .matcher(sourcePageUnicodeDecoded);</span>
    }

    /**
     * After ${lead} tag, gets characters between 1 and maxPerf
     * performanceQuery() gets 65536 characters or fewer
     * ${lead}blahblah1337      ] : end or limit+1
     * ${lead}blahblah      blah] : continue substr()
     */
    private Matcher parseLeadFound(String sourcePage, String performanceLength) throws InjectionFailureException {
        Matcher regexAtLeastOneRow;
        try {
<span class="fc" id="L334">            regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L335">                String.format(&quot;(?s)%s(?i)(.{1,%s})&quot;, LEAD, performanceLength)</span>
            )
<span class="fc" id="L337">            .matcher(sourcePage);</span>
<span class="nc" id="L338">        } catch (PatternSyntaxException e) {</span>
            // Fix #35382 : PatternSyntaxException null on SQLi(.{1,null})
<span class="nc" id="L340">            throw new InjectionFailureException(&quot;Row parsing failed using capacity&quot;, e);</span>
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">        return regexAtLeastOneRow;</span>
    }

    private void checkSuspend(
        AbstractStrategy strategy,
        StringBuilder slidingWindowAllRows,
        StringBuilder slidingWindowCurrentRow
    ) throws StoppedByUserSlidingException, InjectionFailureException {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (this.isSuspended()) {</span>
<span class="nc" id="L351">            throw new StoppedByUserSlidingException(</span>
<span class="nc" id="L352">                slidingWindowAllRows.toString(),</span>
<span class="nc" id="L353">                slidingWindowCurrentRow.toString()</span>
            );
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        } else if (strategy == null) {</span>
            // Fix #1905 : NullPointerException on injectionStrategy.inject()
<span class="nc" id="L357">            throw new InjectionFailureException(&quot;Undefined strategy&quot;);</span>
        }
<span class="fc" id="L359">    }</span>

    private void scrap(StringBuilder slidingWindowAllRows) {
        // Remove everything not properly attached to the last row:
        // 1. very start of a new row: XXXXX\4[\6\4]$
        // 2. very end of the last row: XXXXX[\500]$
<span class="fc" id="L365">        var allRowsLimit = slidingWindowAllRows.toString();</span>
<span class="fc" id="L366">        slidingWindowAllRows.setLength(0);</span>
<span class="fc" id="L367">        slidingWindowAllRows.append(</span>
<span class="fc" id="L368">            Pattern.compile(</span>
<span class="fc" id="L369">                String.format(</span>
                    &quot;%s(%s%s|%s\\d*)$&quot;,
                    MODE,
                    SEPARATOR_CELL_RGX,
                    ENCLOSE_VALUE_RGX,
                    SEPARATOR_QTE_RGX
                )
            )
<span class="fc" id="L377">            .matcher(allRowsLimit)</span>
<span class="fc" id="L378">            .replaceAll(StringUtils.EMPTY)</span>
        );
<span class="fc" id="L380">    }</span>

    private void sendProgress(int numberToFind, int countProgress, AbstractElementDatabase searchName) {
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">        if (numberToFind &gt; 0 &amp;&amp; searchName != null) {</span>
<span class="fc" id="L384">            var request = new Request();</span>
<span class="fc" id="L385">            request.setMessage(Interaction.UPDATE_PROGRESS);</span>
<span class="fc" id="L386">            request.setParameters(searchName, countProgress);</span>
<span class="fc" id="L387">            this.injectionModel.sendToViews(request);</span>
        }
<span class="fc" id="L389">    }</span>
    
    public static List&lt;List&lt;String&gt;&gt; parse(String rows) throws InjectionFailureException {
        // Parse all the data we have retrieved
<span class="fc" id="L393">        var regexSearch = Pattern.compile(</span>
<span class="fc" id="L394">                String.format(</span>
                    &quot;%s%s([^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?)%s([^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?)(\\x08)?%s&quot;,
                    MODE,
                    ENCLOSE_VALUE_RGX,
                    SEPARATOR_QTE_RGX,
                    ENCLOSE_VALUE_RGX
                )
            )
<span class="fc" id="L402">            .matcher(rows);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (!regexSearch.find()) {</span>
<span class="nc" id="L404">            throw new InjectionFailureException();</span>
        }
<span class="fc" id="L406">        regexSearch.reset();</span>
<span class="fc" id="L407">        var rowsFound = 0;</span>
<span class="fc" id="L408">        List&lt;List&lt;String&gt;&gt; listValues = new ArrayList&lt;&gt;();</span>

        // Build a 2D array of strings from the data we have parsed
        // =&gt; row number, occurrence, value1, value2...
<span class="fc bfc" id="L412" title="All 2 branches covered.">        while (regexSearch.find()) {</span>
<span class="fc" id="L413">            String values = regexSearch.group(1);</span>
<span class="fc" id="L414">            var instances = Integer.parseInt(regexSearch.group(2));</span>

<span class="fc" id="L416">            listValues.add(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L417">            listValues.get(rowsFound).add(Integer.toString(rowsFound + 1));</span>
<span class="fc" id="L418">            listValues.get(rowsFound).add(&quot;x&quot;+ instances);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            for (String cellValue: values.split(&quot;\\x7F&quot;, -1)) {</span>
<span class="fc" id="L420">                listValues.get(rowsFound).add(cellValue);</span>
            }
<span class="fc" id="L422">            rowsFound++;</span>
<span class="fc" id="L423">        }</span>
<span class="fc" id="L424">        return listValues;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>